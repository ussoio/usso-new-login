/* tslint:disable */
/* eslint-disable */
/**
 * Usso
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface APIKeyConfig {
    /**
     * Whether API key authentication is enabled
     */
    'enabled'?: boolean;
    /**
     * Prefix for generated API keys
     */
    'prefix'?: string;
    /**
     * Length of generated API keys
     */
    'length'?: number;
}
export interface APIKeyCreateResponseSchema {
    /**
     * Unique identifier for the entity
     */
    'uid'?: string;
    /**
     * Date and time the entity was created
     */
    'created_at'?: string;
    /**
     * Date and time the entity was last updated
     */
    'updated_at'?: string;
    /**
     * Whether the entity has been deleted
     */
    'is_deleted'?: boolean;
    'meta_data'?: { [key: string]: any; } | null;
    'user_id': string;
    'tenant_id': string;
    'api_key_pattern': string;
    'scopes'?: Array<string>;
    'is_active'?: boolean;
    'expires_at'?: string | null;
    'last_used_at'?: string | null;
    'usage_count'?: number;
    'rate_limit'?: { [key: string]: any; };
    /**
     * The API key
     */
    'api_key': string;
}
export interface APIKeyCreateSchema {
    'scopes'?: Array<string>;
}
export interface APIKeyResponseSchema {
    /**
     * Unique identifier for the entity
     */
    'uid'?: string;
    /**
     * Date and time the entity was created
     */
    'created_at'?: string;
    /**
     * Date and time the entity was last updated
     */
    'updated_at'?: string;
    /**
     * Whether the entity has been deleted
     */
    'is_deleted'?: boolean;
    'meta_data'?: { [key: string]: any; } | null;
    'user_id': string;
    'tenant_id': string;
    'api_key_pattern': string;
    'scopes'?: Array<string>;
    'is_active'?: boolean;
    'expires_at'?: string | null;
    'last_used_at'?: string | null;
    'usage_count'?: number;
    'rate_limit'?: { [key: string]: any; };
}
export interface APIKeyVerifySchema {
    'api_key': string;
}

export const ActivationStatus = {
    Active: 'active',
    Deactive: 'deactive',
    Pending: 'pending',
    Banned: 'banned'
} as const;

export type ActivationStatus = typeof ActivationStatus[keyof typeof ActivationStatus];


export interface AgentConfig {
    /**
     * Whether agents are enabled for this tenant
     */
    'enabled'?: boolean;
}
export interface AgentCreateResponse {
    /**
     * Unique identifier for the entity
     */
    'uid'?: string;
    /**
     * Date and time the entity was created
     */
    'created_at'?: string;
    /**
     * Date and time the entity was last updated
     */
    'updated_at'?: string;
    /**
     * Whether the entity has been deleted
     */
    'is_deleted'?: boolean;
    'meta_data'?: { [key: string]: any; } | null;
    'user_id': string;
    'tenant_id': string;
    'name': string;
    'description'?: string | null;
    'alg'?: Algorithm;
    'verify_key'?: string | null;
    'scopes': Array<string>;
    'is_active'?: boolean;
    'last_used_at'?: string | null;
    'type'?: AgentCreateResponseTypeEnum;
    'private_key'?: string | null;
    'client_email'?: string | null;
    'client_id': string;
    'auth_uri'?: string | null;
    'token_uri'?: string | null;
    'auth_provider_x509_cert_url'?: string | null;
    'client_x509_cert_url'?: string | null;
    'universe_domain'?: string | null;
}

export const AgentCreateResponseTypeEnum = {
    Agent: 'agent'
} as const;

export type AgentCreateResponseTypeEnum = typeof AgentCreateResponseTypeEnum[keyof typeof AgentCreateResponseTypeEnum];

export interface AgentCreateSchema {
    'name': string;
    'description'?: string | null;
    'scopes': Array<string>;
    'alg'?: Algorithm;
    'verify_key'?: string | null;
}


export interface AgentSchema {
    /**
     * Unique identifier for the entity
     */
    'uid'?: string;
    /**
     * Date and time the entity was created
     */
    'created_at'?: string;
    /**
     * Date and time the entity was last updated
     */
    'updated_at'?: string;
    /**
     * Whether the entity has been deleted
     */
    'is_deleted'?: boolean;
    'meta_data'?: { [key: string]: any; } | null;
    'user_id': string;
    'tenant_id': string;
    'name': string;
    'description'?: string | null;
    'alg'?: Algorithm;
    'verify_key'?: string | null;
    'scopes': Array<string>;
    'is_active'?: boolean;
    'last_used_at'?: string | null;
}


export interface AgentUpdateSchema {
    'description'?: string | null;
    'scopes'?: Array<string> | null;
    'is_active'?: boolean | null;
}

export const Algorithm = {
    Hs256: 'HS256',
    Hs384: 'HS384',
    Hs512: 'HS512',
    Rs256: 'RS256',
    Rs384: 'RS384',
    Rs512: 'RS512',
    Es256: 'ES256',
    Es384: 'ES384',
    Es512: 'ES512',
    Ps256: 'PS256',
    Ps384: 'PS384',
    Ps512: 'PS512',
    Eddsa: 'EDDSA',
    Ed25519: 'ED25519'
} as const;

export type Algorithm = typeof Algorithm[keyof typeof Algorithm];



export const ApprovalMode = {
    None: 'none',
    Identifier: 'identifier',
    ManualReview: 'manual_review',
    Additional: 'additional'
} as const;

export type ApprovalMode = typeof ApprovalMode[keyof typeof ApprovalMode];


/**
 * OAuth2 Token Types.
 */

export const AppsTenantIntegrationSchemasTokenType = {
    Bearer: 'Bearer',
    Mac: 'MAC'
} as const;

export type AppsTenantIntegrationSchemasTokenType = typeof AppsTenantIntegrationSchemasTokenType[keyof typeof AppsTenantIntegrationSchemasTokenType];


/**
 * Configuration for a authentication flow.  This model defines a sequence of authentication steps, where each step can have multiple parallel methods. The flow starts with a list of allowed identifiers that can be used to identify the user.  Example: AuthFlow(     allowed_identifiers=[AuthIdentifier.EMAIL, AuthIdentifier.PHONE],     steps=[         LoginStep(             methods=[AuthSecret.PASSWORD],             required_num=1         ),         LoginStep(             methods=[AuthSecret.TOTP, AuthSecret.EMAIL_OTP],             required_num=1         )     ] )
 */
export interface AuthFlow {
    /**
     * List of allowed identifier types for this flow
     */
    'allowed_identifiers': Array<AuthIdentifier>;
    /**
     * List of authentication steps in sequence
     */
    'steps'?: Array<AuthStep>;
}
/**
 * Authentication identifiers.  These are the ways a user or application can be identified in the system. Each identifier type represents a different way to look up an entity.
 */

export const AuthIdentifier = {
    Email: 'email',
    Phone: 'phone',
    Username: 'username',
    TelegramId: 'telegram_id',
    PasskeyId: 'passkey_id',
    QrSession: 'qr_session',
    NationalId: 'national_id',
    ClientId: 'client_id',
    ServiceId: 'service_id'
} as const;

export type AuthIdentifier = typeof AuthIdentifier[keyof typeof AuthIdentifier];


/**
 * Authentication secrets.  These are the methods used to verify the identity of a user. Each secret type represents a different way to prove identity.
 */

export const AuthSecret = {
    Password: 'password',
    Totp: 'totp',
    EmailOtp: 'email/otp',
    PhoneOtp: 'phone/otp',
    BackupCodes: 'backup_codes',
    Webauthn: 'webauthn',
    MagicLink: 'magic_link',
    Oauth: 'oauth',
    IdToken: 'id_token',
    TelegramToken: 'telegram_token'
} as const;

export type AuthSecret = typeof AuthSecret[keyof typeof AuthSecret];


/**
 * Represents an authentication session for a user or service.  Stores session metadata, authentication flow used, and expiration logic. Used for tracking active sessions, auditing, and enforcing security policies.
 */
export interface AuthSessionSchema {
    /**
     * Unique identifier for the entity
     */
    'uid'?: string;
    /**
     * Date and time the entity was created
     */
    'created_at'?: string;
    /**
     * Date and time the entity was last updated
     */
    'updated_at'?: string;
    /**
     * Whether the entity has been deleted
     */
    'is_deleted'?: boolean;
    'meta_data'?: { [key: string]: any; } | null;
    'user_id': string;
    'tenant_id': string;
    'workspace_id'?: string | null;
    'aud'?: string | null;
    'scopes'?: Array<string> | null;
    /**
     * Authentication methods used to create the session
     */
    'amr'?: Array<string>;
    /**
     * Timestamp of the last session refresh (for sliding expiration)
     */
    'last_used_at'?: string;
    'max_age_minutes'?: number | null;
    /**
     * User agent string of the client initiating the session
     */
    'user_agent': string;
    /**
     * IP address from which the session was initiated
     */
    'ip': string;
    'location'?: string | null;
    'session_type'?: SessionType;
}


/**
 * A single step in the login flow that can have multiple parallel authentication methods.
 */
export interface AuthStep {
    /**
     * List of authentication methods that can be used in this step
     */
    'methods': Array<AuthSecret>;
    /**
     * Number of methods that must be passed in this step
     */
    'required_num'?: number;
}
/**
 * Authentication configuration for a tenant. Defines the login flow(s) and related policies.
 */
export interface AuthenticationConfig {
    /**
     * The login flow configuration for this tenant
     */
    'login_flow'?: AuthFlow;
    'mfa_timeout'?: number;
    'otp_timeout'?: number;
    'otp_length'?: number;
    'magic_link_timeout'?: number;
    'password_min_length'?: number;
    'password_prevent_reuse'?: boolean;
    'password_prevent_dictionary'?: boolean;
    'password_require_special'?: boolean;
    'password_require_numbers'?: boolean;
    'password_require_uppercase'?: boolean;
    'password_require_lowercase'?: boolean;
    'max_concurrent_sessions'?: number | null;
    'session_inactivity_timeout'?: number | null;
    /**
     * Require recent authentication for sensitive actions
     */
    'require_recent_authentication'?: boolean;
}
/**
 * AuthenticatorAttestationResponse from WebAuthn.
 */
export interface AuthenticatorAttestationResponse {
    'attestationObject'?: string | null;
    /**
     * Base64url-encoded client data
     */
    'clientDataJSON': string;
    /**
     * Base64url-encoded authenticator data
     */
    'authenticatorData': string;
    'signature'?: string | null;
    'userHandle'?: string | null;
}
export interface BaseEntitySchema {
    /**
     * Unique identifier for the entity
     */
    'uid'?: string;
    /**
     * Date and time the entity was created
     */
    'created_at'?: string;
    /**
     * Date and time the entity was last updated
     */
    'updated_at'?: string;
    /**
     * Whether the entity has been deleted
     */
    'is_deleted'?: boolean;
    'meta_data'?: { [key: string]: any; } | null;
}
export interface BodyVerifyApiSsoV1CaptchaVerifyPost {
    'payload'?: string | null;
    'code'?: string | null;
}
export interface BrandingModel {
    'primary_color'?: string;
    'secondary_color'?: string;
    'font_family'?: string;
    'logo'?: string;
    'favicon'?: string | null;
    'custom_css'?: string | null;
}
/**
 * Dynamic Client Registration Request schema.
 */
export interface ClientRegistrationRequestSchema {
    /**
     * Human-readable client name
     */
    'client_name': string;
    /**
     * Redirect URIs
     */
    'redirect_uris': Array<string>;
    /**
     * Grant types
     */
    'grant_types'?: Array<GrantType>;
    /**
     * Response types
     */
    'response_types'?: Array<ResponseType>;
    /**
     * Requested scopes
     */
    'scope'?: string;
    'logo_uri'?: string | null;
    'client_uri'?: string | null;
    'policy_uri'?: string | null;
    'tos_uri'?: string | null;
    'jwks_uri'?: string | null;
    'jwks'?: { [key: string]: any; } | null;
    'software_id'?: string | null;
    'software_version'?: string | null;
}
/**
 * Dynamic Client Registration Response schema.
 */
export interface ClientRegistrationResponseSchema {
    /**
     * Unique identifier for the entity
     */
    'uid'?: string;
    /**
     * Date and time the entity was created
     */
    'created_at'?: string;
    /**
     * Date and time the entity was last updated
     */
    'updated_at'?: string;
    /**
     * Whether the entity has been deleted
     */
    'is_deleted'?: boolean;
    'meta_data'?: { [key: string]: any; } | null;
    'user_id': string;
    'tenant_id': string;
    /**
     * Unique client identifier
     */
    'client_id': string;
    /**
     * Client secret (for confidential clients)
     */
    'client_secret': string;
    /**
     * Human-readable client name
     */
    'client_name': string;
    /**
     * Client type (public or confidential)
     */
    'client_type': ClientType;
    /**
     * Allowed redirect URIs
     */
    'redirect_uris': Array<string>;
    /**
     * Allowed scopes for this client
     */
    'allowed_scopes'?: Array<Scope>;
    /**
     * Allowed grant types
     */
    'grant_types'?: Array<GrantType>;
    /**
     * Allowed response types
     */
    'response_types'?: Array<ResponseType>;
    'logo_uri'?: string | null;
    'client_uri'?: string | null;
    'policy_uri'?: string | null;
    'tos_uri'?: string | null;
    /**
     * Require PKCE for authorization code flow
     */
    'require_pkce'?: boolean;
    /**
     * Token endpoint authentication method
     */
    'token_endpoint_auth_method'?: string;
    /**
     * Whether the client is active
     */
    'is_active'?: boolean;
    /**
     * Client ID issuance timestamp
     */
    'client_id_issued_at': number;
    /**
     * Client secret expiration
     */
    'client_secret_expires_at'?: number;
    /**
     * Registration access token
     */
    'registration_access_token': string;
}


/**
 * OAuth2 Client Types.
 */

export const ClientType = {
    Confidential: 'confidential'
} as const;

export type ClientType = typeof ClientType[keyof typeof ClientType];


/**
 * Schema for updating OAuth client (partial update).
 */
export interface ClientUpdateSchema {
    'client_name'?: string | null;
    'redirect_uris'?: Array<string> | null;
    'allowed_scopes'?: Array<Scope> | null;
    'grant_types'?: Array<GrantType> | null;
    'response_types'?: Array<ResponseType> | null;
    'logo_uri'?: string | null;
    'client_uri'?: string | null;
    'policy_uri'?: string | null;
    'tos_uri'?: string | null;
    'require_pkce'?: boolean | null;
    'token_endpoint_auth_method'?: string | null;
    'is_active'?: boolean | null;
}
export interface Credential {
    '_id'?: string;
    /**
     * Unique identifier for the entity
     */
    'uid'?: string;
    /**
     * Date and time the entity was created
     */
    'created_at'?: string;
    /**
     * Date and time the entity was last updated
     */
    'updated_at'?: string;
    /**
     * Whether the entity has been deleted
     */
    'is_deleted'?: boolean;
    'meta_data'?: { [key: string]: any; } | null;
    'user_id': string;
    'tenant_id': string;
    'method': AuthSecret;
    'secret': string;
    'last_used_at'?: string | null;
    'is_active'?: boolean;
    'expires_at'?: string | null;
}


/**
 * Schema for creating new credentials.
 */
export interface CredentialCreateSchema {
    'method': AuthSecret;
    'secret': string;
    'expires_at'?: string | null;
}


/**
 * Response schema for credentials - excludes sensitive data.
 */
export interface CredentialResponseSchema {
    /**
     * Unique identifier for the entity
     */
    'uid'?: string;
    /**
     * Date and time the entity was created
     */
    'created_at'?: string;
    /**
     * Date and time the entity was last updated
     */
    'updated_at'?: string;
    /**
     * Whether the entity has been deleted
     */
    'is_deleted'?: boolean;
    'meta_data'?: { [key: string]: any; } | null;
    'user_id': string;
    'tenant_id': string;
    'method': AuthSecret;
    'last_used_at'?: string | null;
    'is_active'?: boolean;
    'expires_at'?: string | null;
}


export interface Data {
    'email': string;
    'password': string;
    'otp': string;
    'phone': string;
    'username': string;
}
export interface EmailOtpLogin {
    'email': string;
    'otp': string;
}
export interface EmailPasswordLogin {
    'email': string;
    'password': string;
}
/**
 * Schema for creating a new routing keymap entry.
 */
export interface GatewayRouteCreateSchema {
    /**
     * A URL-friendly slug for the routing keymap, must be unique.
     */
    'slug': string;
    /**
     * The scopes required for the plugin.
     */
    'scopes': Array<string>;
    /**
     * A human-readable display name for the routing keymap.
     */
    'title': string;
    'description'?: string | null;
    'icon'?: string | null;
    /**
     * The upstream for the service.
     */
    'upstream': Upstream;
    'front_visible'?: boolean;
}
export interface GatewayRouteSchema {
    /**
     * Unique identifier for the entity
     */
    'uid'?: string;
    /**
     * Date and time the entity was created
     */
    'created_at'?: string;
    /**
     * Date and time the entity was last updated
     */
    'updated_at'?: string;
    /**
     * Whether the entity has been deleted
     */
    'is_deleted'?: boolean;
    'meta_data'?: { [key: string]: any; } | null;
    'user_id': string;
    'tenant_id': string;
    /**
     * A URL-friendly slug for the routing keymap, must be unique.
     */
    'slug': string;
    /**
     * The scopes required for the plugin.
     */
    'scopes': Array<string>;
    /**
     * A human-readable display name for the routing keymap.
     */
    'title': string;
    'description'?: string | null;
    'icon'?: string | null;
    /**
     * The upstream for the service.
     */
    'upstream': Upstream;
    'front_visible'?: boolean;
}
/**
 * OAuth2 Grant Types.
 */

export const GrantType = {
    AuthorizationCode: 'authorization_code',
    ClientCredentials: 'client_credentials',
    RefreshToken: 'refresh_token'
} as const;

export type GrantType = typeof GrantType[keyof typeof GrantType];


export interface HTTPValidationError {
    'detail'?: Array<ValidationError>;
}
export interface Identifier {
    'type'?: AuthIdentifier | null;
    /**
     * Identifier value (email, phone, username, etc.)
     */
    'identifier': string;
}


export interface IntegrationConfig {
    /**
     * Dictionary of OAuth2 provider configurations, keyed by provider name
     */
    'oauth_providers'?: { [key: string]: OAuthProviderConfig; };
    'oidc'?: OIDCConfig | null;
    'api_key'?: APIKeyConfig;
    'service_account'?: ServiceAccountConfig;
    /**
     * List of webhook configurations for this tenant
     */
    'webhooks'?: Array<WebhookConfig>;
}
export interface LegalModel {
    'terms_url'?: string | null;
    'privacy_url'?: string | null;
    'imprint_url'?: string | null;
    'cookie_policy_url'?: string | null;
    'data_processing_agreement_url'?: string | null;
}
export interface LoginRequest {
    'method'?: AuthSecret | null;
    'secret'?: string | null;
    'type'?: AuthIdentifier | null;
    /**
     * Identifier value (email, phone, username, etc.)
     */
    'identifier': string;
    'referral_code'?: string | null;
}


export interface LoginResponse {
    'iss'?: string | null;
    'sub'?: string | null;
    'aud'?: string | null;
    'iat'?: number | null;
    'nbf'?: number | null;
    'exp'?: number | null;
    'jti'?: string | null;
    'token_type'?: UssoUserTokenType | null;
    'session_id'?: string | null;
    'tenant_id'?: string | null;
    'workspace_id'?: string | null;
    'roles'?: Array<string> | null;
    'scopes'?: Array<string> | null;
    'acr'?: string | null;
    'amr'?: Array<string> | null;
    'signing_level'?: string | null;
    'claims'?: { [key: string]: any; } | null;
    'next_step'?: AuthStep | null;
    'status'?: LoginStatus;
    'tokens'?: { [key: string]: string; } | null;
}



export const LoginStatus = {
    RegistrationRequired: 'registration_required',
    VerificationRequired: 'verification_required',
    MfaRequired: 'mfa_required',
    Completed: 'completed',
    Failed: 'failed',
    Refreshed: 'refreshed'
} as const;

export type LoginStatus = typeof LoginStatus[keyof typeof LoginStatus];


export interface MagicLinkRequest {
    'type'?: AuthIdentifier | null;
    /**
     * Identifier value (email, phone, username, etc.)
     */
    'identifier': string;
}



export const MessageChannelType = {
    Email: 'email',
    Sms: 'sms',
    Whatsapp: 'whatsapp',
    Telegram: 'telegram',
    Bale: 'bale'
} as const;

export type MessageChannelType = typeof MessageChannelType[keyof typeof MessageChannelType];


export interface MessageTemplate {
    /**
     * Name of the template
     */
    'name'?: string;
    'template_type'?: TemplateType;
    'channel'?: MessageChannelType;
    'source_type'?: TemplateSourceType;
    'subject'?: string | null;
    'path'?: string | null;
    'url'?: string | null;
    'inline_body'?: string | null;
    'remote_template_id'?: string | null;
    'variables'?: Array<string>;
}


/**
 * Configuration for OAuth provider settings.  Attributes:     name: The name of the OAuth provider (e.g., \'google\', \'github\')     client_id: The OAuth client ID provided by the OAuth provider     client_secret: The OAuth client secret provided by the OAuth provider     redirect_uri: The callback URL where the OAuth                   provider will redirect after authentication     scopes: List of OAuth scopes to request from the provider
 */
export interface OAuthProviderConfig {
    /**
     * The name of the OAuth provider (e.g., \'google\', \'github\')
     */
    'name': string;
    /**
     * The OAuth client ID provided by the OAuth provider
     */
    'client_id': string;
    /**
     * The OAuth client secret provided by the OAuth provider
     */
    'client_secret': string;
    'redirect_uri'?: string | null;
    /**
     * List of OAuth scopes to request from the provider
     */
    'scopes'?: Array<string>;
}
export interface OIDCConfig {
    /**
     * Whether OIDC functionality is enabled
     */
    'enabled'?: boolean;
    /**
     * OIDC issuer URL
     */
    'issuer_url': string;
    /**
     * OIDC JWKS URI
     */
    'jwks_uri': string;
}
export interface OTPRequest {
    'type'?: AuthIdentifier | null;
    /**
     * Identifier value (email, phone, username, etc.)
     */
    'identifier': string;
    /**
     * Channel type: sms, email, bale, etc
     */
    'channel_type'?: string;
}


export interface PaginatedResponseAPIKeyResponseSchema {
    'heads'?: { [key: string]: { [key: string]: string; }; };
    'items': Array<APIKeyResponseSchema>;
    'total': number;
    'offset': number;
    'limit': number;
}
export interface PaginatedResponseAgentSchema {
    'heads'?: { [key: string]: { [key: string]: string; }; };
    'items': Array<AgentSchema>;
    'total': number;
    'offset': number;
    'limit': number;
}
export interface PaginatedResponseAuthSessionSchema {
    'heads'?: { [key: string]: { [key: string]: string; }; };
    'items': Array<AuthSessionSchema>;
    'total': number;
    'offset': number;
    'limit': number;
}
export interface PaginatedResponseCredentialResponseSchema {
    'heads'?: { [key: string]: { [key: string]: string; }; };
    'items': Array<CredentialResponseSchema>;
    'total': number;
    'offset': number;
    'limit': number;
}
export interface PaginatedResponseGatewayRouteSchema {
    'heads'?: { [key: string]: { [key: string]: string; }; };
    'items': Array<GatewayRouteSchema>;
    'total': number;
    'offset': number;
    'limit': number;
}
export interface PaginatedResponseProfileSchema {
    'heads'?: { [key: string]: { [key: string]: string; }; };
    'items': Array<ProfileSchema>;
    'total': number;
    'offset': number;
    'limit': number;
}
export interface PaginatedResponseReferralCodeSchema {
    'heads'?: { [key: string]: { [key: string]: string; }; };
    'items': Array<ReferralCodeSchema>;
    'total': number;
    'offset': number;
    'limit': number;
}
export interface PaginatedResponseRoleSchema {
    'heads'?: { [key: string]: { [key: string]: string; }; };
    'items': Array<RoleSchema>;
    'total': number;
    'offset': number;
    'limit': number;
}
export interface PaginatedResponseTenantRetrieveSchema {
    'heads'?: { [key: string]: { [key: string]: string; }; };
    'items': Array<TenantRetrieveSchema>;
    'total': number;
    'offset': number;
    'limit': number;
}
export interface PaginatedResponseUserIdentifierSchema {
    'heads'?: { [key: string]: { [key: string]: string; }; };
    'items': Array<UserIdentifierSchema>;
    'total': number;
    'offset': number;
    'limit': number;
}
export interface PaginatedResponseUserResponse {
    'heads'?: { [key: string]: { [key: string]: string; }; };
    'items': Array<UserResponse>;
    'total': number;
    'offset': number;
    'limit': number;
}
export interface PaginatedResponseWorkspaceSchema {
    'heads'?: { [key: string]: { [key: string]: string; }; };
    'items': Array<WorkspaceSchema>;
    'total': number;
    'offset': number;
    'limit': number;
}
/**
 * SimpleWebAuthn registration response format.
 */
export interface PasskeyAssertion {
    'type'?: PasskeyAssertionTypeEnum;
    /**
     * Base64url-encoded credential ID
     */
    'id': string;
    /**
     * Base64url-encoded raw credential ID
     */
    'rawId': string;
    'authenticatorAttachment'?: PasskeyAssertionAuthenticatorAttachmentEnum | null;
    'clientExtensionResults'?: { [key: string]: any; } | null;
    /**
     * Authenticator attestation response
     */
    'response': AuthenticatorAttestationResponse;
}

export const PasskeyAssertionTypeEnum = {
    PublicKey: 'public-key'
} as const;

export type PasskeyAssertionTypeEnum = typeof PasskeyAssertionTypeEnum[keyof typeof PasskeyAssertionTypeEnum];
export const PasskeyAssertionAuthenticatorAttachmentEnum = {
    Platform: 'platform',
    CrossPlatform: 'cross-platform'
} as const;

export type PasskeyAssertionAuthenticatorAttachmentEnum = typeof PasskeyAssertionAuthenticatorAttachmentEnum[keyof typeof PasskeyAssertionAuthenticatorAttachmentEnum];

export interface PayloadData {
    'iss'?: string | null;
    'sub'?: string | null;
    'aud'?: string | null;
    'iat'?: number | null;
    'nbf'?: number | null;
    'exp'?: number | null;
    'jti'?: string | null;
    'token_type'?: UssoUserTokenType | null;
    'session_id'?: string | null;
    'tenant_id'?: string | null;
    'workspace_id'?: string | null;
    'roles'?: Array<string> | null;
    'scopes'?: Array<string> | null;
    'acr'?: string | null;
    'amr'?: Array<string> | null;
    'signing_level'?: string | null;
    'claims'?: { [key: string]: any; } | null;
}


export interface PhoneOtpLogin {
    'phone': string;
    'otp': string;
}
export interface PhonePasswordLogin {
    'phone': string;
    'password': string;
}
export interface ProfileCreateSchema {
    'user_id': string | null;
    'meta_data'?: { [key: string]: any; } | null;
    'profile_data'?: { [key: string]: any; };
}
export interface ProfileSchema {
    /**
     * Unique identifier for the entity
     */
    'uid'?: string;
    /**
     * Date and time the entity was created
     */
    'created_at'?: string;
    /**
     * Date and time the entity was last updated
     */
    'updated_at'?: string;
    /**
     * Whether the entity has been deleted
     */
    'is_deleted'?: boolean;
    'meta_data'?: { [key: string]: any; } | null;
    'user_id': string;
    'tenant_id': string;
    'profile_data'?: { [key: string]: any; };
}
export interface ProfileUpdateSchema {
    'meta_data'?: { [key: string]: any; } | null;
    'profile_data'?: { [key: string]: any; } | null;
}
export interface QRCodeResponse {
    'qr_token': string;
}
export interface QRLoginRequest {
    'qr_code': string;
    /**
     * Base64 encoded QR code image
     */
    'qr': string;
}
export interface ReferralCodeSchema {
    /**
     * Unique identifier for the entity
     */
    'uid'?: string;
    /**
     * Date and time the entity was created
     */
    'created_at'?: string;
    /**
     * Date and time the entity was last updated
     */
    'updated_at'?: string;
    /**
     * Whether the entity has been deleted
     */
    'is_deleted'?: boolean;
    'meta_data'?: { [key: string]: any; } | null;
    'user_id': string;
    'tenant_id': string;
    'code'?: string;
    'expires_at'?: string | null;
    'is_active'?: boolean;
    'usage_count'?: number;
    'max_usage'?: number | null;
}
export interface RefreshRequest {
    'refresh_token': string;
}
export interface RefreshResponse {
    'status'?: LoginStatus;
    'tokens'?: { [key: string]: string; } | null;
    'expires_in'?: number | null;
}


export interface RegistrationConfig {
    'is_allowed'?: boolean;
    'approval_mode'?: ApprovalMode;
    'allow_self_deactivate'?: boolean;
    'invite_only'?: boolean;
}


export interface ResetPasswordRequest {
    'secure_token'?: string | null;
    'new_password': string;
}
export interface ResponseGetJwksWellKnownJwksJsonGetValueInnerValue {
}
export interface ResponseGetOpenidConfigurationWellKnownOpenidConfigurationGetValue {
}
/**
 * OAuth2 Response Types.
 */

export const ResponseType = {
    Code: 'code',
    Token: 'token',
    IdToken: 'id_token',
    CodeIdToken: 'code id_token'
} as const;

export type ResponseType = typeof ResponseType[keyof typeof ResponseType];


export interface RoleCreateSchema {
    'name': string;
    'description'?: string | null;
    'scopes'?: Array<string>;
    'is_active'?: boolean;
    'workspace_id'?: string | null;
}
export interface RoleSchema {
    /**
     * Unique identifier for the entity
     */
    'uid'?: string;
    /**
     * Date and time the entity was created
     */
    'created_at'?: string;
    /**
     * Date and time the entity was last updated
     */
    'updated_at'?: string;
    /**
     * Whether the entity has been deleted
     */
    'is_deleted'?: boolean;
    'meta_data'?: { [key: string]: any; } | null;
    'tenant_id': string;
    'name': string;
    'description'?: string | null;
    'scopes'?: Array<string>;
    'is_active'?: boolean;
    'workspace_id'?: string | null;
}
export interface RoleUpdateSchema {
    'name'?: string | null;
    'description'?: string | null;
    'scopes'?: Array<string> | null;
    'is_active'?: boolean | null;
}
/**
 * OAuth2 Scopes.
 */

export const Scope = {
    Openid: 'openid',
    Profile: 'profile',
    Email: 'email'
} as const;

export type Scope = typeof Scope[keyof typeof Scope];


export interface ServiceAccountConfig {
    /**
     * Whether service account authentication is enabled
     */
    'enabled'?: boolean;
    /**
     * Prefix for generated service account IDs
     */
    'prefix'?: string;
}
/**
 * Types of authentication sessions in the system.  Authentication sessions are categorized based on how they were created and their intended usage pattern.
 */

export const SessionType = {
    Temporary: 'temporary',
    RegularLogin: 'regular_login',
    AccountRecovery: 'account_recovery',
    CredentialRecovery: 'credential_recovery',
    Impersonation: 'impersonation',
    ApiKey: 'api_key',
    OauthClient: 'oauth_client',
    OauthSession: 'oauth_session',
    ServiceAccount: 'service_account',
    OneTimeAccess: 'one_time_access'
} as const;

export type SessionType = typeof SessionType[keyof typeof SessionType];



export const TemplateSourceType = {
    File: 'file',
    Url: 'url',
    Inline: 'inline',
    Remote: 'remote'
} as const;

export type TemplateSourceType = typeof TemplateSourceType[keyof typeof TemplateSourceType];



export const TemplateType = {
    Verification: 'verification',
    ResetPassword: 'reset_password',
    MagicLink: 'magic_link',
    EmailOtp: 'email_otp',
    SmsOtp: 'sms_otp'
} as const;

export type TemplateType = typeof TemplateType[keyof typeof TemplateType];


export interface TenantConfig {
    'branding'?: BrandingModel;
    'legal'?: LegalModel;
    'default_redirect_url'?: string;
    'auth'?: AuthenticationConfig;
    'token'?: TokenConfig;
    'integration'?: IntegrationConfig;
    /**
     * Number of image captcha tries
     */
    'image_captcha_tries'?: number;
    'workspace'?: WorkspaceConfig;
    'agents'?: AgentConfig;
    'templates'?: { [key: string]: MessageTemplate; };
    'registration'?: RegistrationConfig;
}
export interface TenantCreateSchema {
    /**
     * Name of the tenant/organization
     */
    'name': string;
    /**
     * The domains of the tenant\'s SSO application
     */
    'domains': Array<string>;
    'algorithm'?: Algorithm;
}


export interface TenantFrontendURLConfig {
    'login_url'?: string;
    'register_url'?: string;
    'reset_password_url'?: string;
    'request_otp_url'?: string;
    'verify_email_url'?: string;
    'verify_phone_url'?: string;
    'verify_national_id_url'?: string;
    'verify_id_url'?: string;
    'magic_link_url'?: string;
    'passkey_url'?: string;
    'qr_url'?: string;
    'oauth_authorize_url'?: string;
    'oauth_failed_url'?: string;
    'consent_url'?: string;
}
export interface TenantRetrieveSchema {
    /**
     * Unique identifier for the entity
     */
    'uid'?: string;
    /**
     * Date and time the entity was created
     */
    'created_at'?: string;
    /**
     * Date and time the entity was last updated
     */
    'updated_at'?: string;
    /**
     * Whether the entity has been deleted
     */
    'is_deleted'?: boolean;
    'meta_data'?: { [key: string]: any; } | null;
    'user_id': string;
    /**
     * Name of the tenant/organization
     */
    'name': string;
    /**
     * Whether the tenant is active
     */
    'is_active'?: boolean;
    /**
     * The domains of the tenant\'s SSO application
     */
    'domains': Array<string>;
    /**
     * Tenant configuration
     */
    'config'?: TenantConfig;
    /**
     * Tenant frontend URLs
     */
    'frontend_urls'?: TenantFrontendURLConfig;
    'custom_payload'?: { [key: string]: any; } | null;
}
export interface TenantUpdateSchema {
    'name'?: string | null;
    'domains'?: Array<string> | null;
    'is_active'?: boolean | null;
}
export interface TokenConfig {
    'access_timeout'?: number;
    'refresh_timeout'?: number;
    'refresh_token_rotation'?: boolean;
    'refresh_sliding_timeout'?: number;
    'refresh_token_reuse_grace_period'?: number;
    'temporary_token_timeout'?: number;
    'secure_action_timeout'?: number;
    'secure_action_max_uses'?: number;
    'secure_session_timeout'?: number;
}
/**
 * OAuth2 Token Introspection Response schema.
 */
export interface TokenIntrospectionResponseSchema {
    /**
     * Whether the token is active
     */
    'active': boolean;
    'scope'?: string | null;
    'client_id'?: string | null;
    'username'?: string | null;
    'token_type'?: string | null;
    'exp'?: number | null;
    'iat'?: number | null;
    'nbf'?: number | null;
    'sub'?: string | null;
    'aud'?: string | null;
    'iss'?: string | null;
    'jti'?: string | null;
}
/**
 * OAuth2 Token Response schema.
 */
export interface TokenResponseSchema {
    /**
     * Access token
     */
    'access_token': string;
    /**
     * Token type
     */
    'token_type'?: AppsTenantIntegrationSchemasTokenType;
    /**
     * Token expiration time in seconds
     */
    'expires_in': number;
    'refresh_token'?: string | null;
    'scope'?: string | null;
    'id_token'?: string | null;
}


export interface Upstream {
    'api_url'?: string | null;
    'dashboard_url'?: string | null;
}
export interface UserCreateSchema {
    'name'?: string | null;
    'identifier_type'?: AuthIdentifier;
    /**
     * Identifier address
     */
    'identifier': string;
    'roles'?: Array<string>;
}


export interface UserData {
    'iss'?: string | null;
    'sub'?: string | null;
    'aud'?: string | null;
    'iat'?: number | null;
    'nbf'?: number | null;
    'exp'?: number | null;
    'jti'?: string | null;
    'token_type'?: UssoUserTokenType | null;
    'session_id'?: string | null;
    'tenant_id'?: string | null;
    'workspace_id'?: string | null;
    'roles'?: Array<string> | null;
    'scopes'?: Array<string> | null;
    'acr'?: string | null;
    'amr'?: Array<string> | null;
    'signing_level'?: string | null;
    'claims'?: { [key: string]: any; } | null;
}


export interface UserIdentifier {
    '_id'?: string;
    /**
     * Unique identifier for the entity
     */
    'uid'?: string;
    /**
     * Date and time the entity was created
     */
    'created_at'?: string;
    /**
     * Date and time the entity was last updated
     */
    'updated_at'?: string;
    /**
     * Whether the entity has been deleted
     */
    'is_deleted'?: boolean;
    'meta_data'?: { [key: string]: any; } | null;
    'user_id': string;
    'tenant_id': string;
    'type': AuthIdentifier | null;
    'identifier': string;
    'verified_at'?: string | null;
    'is_primary'?: boolean;
    'is_active'?: boolean;
}


/**
 * Schema for creating new user identifiers.
 */
export interface UserIdentifierCreateSchema {
    'type': AuthIdentifier;
    'identifier': string;
    'is_primary'?: boolean;
}


export interface UserIdentifierSchema {
    /**
     * Unique identifier for the entity
     */
    'uid'?: string;
    /**
     * Date and time the entity was created
     */
    'created_at'?: string;
    /**
     * Date and time the entity was last updated
     */
    'updated_at'?: string;
    /**
     * Whether the entity has been deleted
     */
    'is_deleted'?: boolean;
    'meta_data'?: { [key: string]: any; } | null;
    'user_id': string;
    'tenant_id': string;
    'type': AuthIdentifier | null;
    'identifier': string;
    'verified_at'?: string | null;
    'is_primary'?: boolean;
    'is_active'?: boolean;
}


/**
 * Schema for updating user identifiers.
 */
export interface UserIdentifierUpdateSchema {
    'is_primary'?: boolean | null;
    'is_active'?: boolean | null;
}
/**
 * OpenID Connect UserInfo Response schema.
 */
export interface UserInfoResponseSchema {
    /**
     * Subject identifier
     */
    'sub': string;
    'name'?: string | null;
    'given_name'?: string | null;
    'family_name'?: string | null;
    'middle_name'?: string | null;
    'nickname'?: string | null;
    'preferred_username'?: string | null;
    'profile'?: string | null;
    'picture'?: string | null;
    'website'?: string | null;
    'email'?: string | null;
    'email_verified'?: boolean | null;
    'gender'?: string | null;
    'birthdate'?: string | null;
    'zoneinfo'?: string | null;
    'locale'?: string | null;
    'phone_number'?: string | null;
    'phone_number_verified'?: boolean | null;
    'address'?: { [key: string]: any; } | null;
    'updated_at'?: number | null;
}
export interface UserResponse {
    /**
     * Unique identifier for the entity
     */
    'uid'?: string;
    /**
     * Date and time the entity was created
     */
    'created_at'?: string;
    /**
     * Date and time the entity was last updated
     */
    'updated_at'?: string;
    /**
     * Whether the entity has been deleted
     */
    'is_deleted'?: boolean;
    'meta_data'?: { [key: string]: any; } | null;
    'tenant_id': string;
    'name'?: string | null;
    'roles': Array<string>;
    'scopes'?: Array<string> | null;
    'workspace_roles'?: { [key: string]: Array<string>; };
    'workspace_ids'?: Array<string>;
    'is_active'?: boolean;
    'is_limited'?: boolean;
    'activation_status'?: ActivationStatus;
    'avatar_url'?: string | null;
    'custom_claims'?: { [key: string]: any; };
    'history'?: Array<{ [key: string]: any; } | null>;
    'identifiers'?: Array<UserIdentifierSchema>;
    'credential_methods'?: Array<string>;
}


export interface UserUpdateSchema {
    'name'?: string | null;
    'roles'?: Array<string> | null;
    'scopes'?: Array<string> | null;
    'workspace_roles'?: { [key: string]: Array<string>; } | null;
    'workspace_ids'?: Array<string> | null;
    'is_active'?: boolean | null;
    'is_limited'?: boolean | null;
    'activation_status'?: ActivationStatus | null;
    'avatar_url'?: string | null;
    'custom_claims'?: { [key: string]: any; } | null;
}


export interface UsernameOtpLogin {
    'username': string;
    'otp': string;
}
export interface UsernamePasswordLogin {
    'username': string;
    'password': string;
}

export const UssoUserTokenType = {
    Access: 'access',
    Refresh: 'refresh',
    Secure: 'secure',
    OneTime: 'one_time',
    Temporary: 'temporary'
} as const;

export type UssoUserTokenType = typeof UssoUserTokenType[keyof typeof UssoUserTokenType];


export interface ValidationError {
    'loc': Array<ValidationErrorLocInner>;
    'msg': string;
    'type': string;
}
export interface ValidationErrorLocInner {
}
export interface VerifyTokenRequest {
    'token': string;
    'token_type'?: UssoUserTokenType;
}


export interface WebhookConfig {
    /**
     * The webhook endpoint URL
     */
    'url': string;
    'headers'?: { [key: string]: string; } | null;
    /**
     * List of events that trigger this webhook
     */
    'events'?: Array<string>;
}
export interface WorkspaceConfig {
    /**
     * Whether workspace is enabled
     */
    'enabled'?: boolean;
}
export interface WorkspaceSchema {
    /**
     * Unique identifier for the entity
     */
    'uid'?: string;
    /**
     * Date and time the entity was created
     */
    'created_at'?: string;
    /**
     * Date and time the entity was last updated
     */
    'updated_at'?: string;
    /**
     * Whether the entity has been deleted
     */
    'is_deleted'?: boolean;
    'meta_data'?: { [key: string]: any; } | null;
    'tenant_id': string;
    'name': string;
    'description'?: string | null;
    'slug': string;
    'logo_url'?: string | null;
    'is_active'?: boolean;
    'settings'?: { [key: string]: any; };
}

/**
 * APIKeyApi - axios parameter creator
 */
export const APIKeyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Item
         * @param {APIKeyCreateSchema} aPIKeyCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemApiSsoV1ApikeysPost: async (aPIKeyCreateSchema: APIKeyCreateSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'aPIKeyCreateSchema' is not null or undefined
            assertParamExists('createItemApiSsoV1ApikeysPost', 'aPIKeyCreateSchema', aPIKeyCreateSchema)
            const localVarPath = `/api/sso/v1/apikeys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aPIKeyCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemApiSsoV1ApikeysUidDelete: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteItemApiSsoV1ApikeysUidDelete', 'uid', uid)
            const localVarPath = `/api/sso/v1/apikeys/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemsApiSsoV1ApikeysGet: async (offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/v1/apikeys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (createdAtFrom !== undefined) {
                localVarQueryParameter['created_at_from'] = (createdAtFrom as any instanceof Date) ?
                    (createdAtFrom as any).toISOString() :
                    createdAtFrom;
            }

            if (createdAtTo !== undefined) {
                localVarQueryParameter['created_at_to'] = (createdAtTo as any instanceof Date) ?
                    (createdAtTo as any).toISOString() :
                    createdAtTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveItemApiSsoV1ApikeysUidGet: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('retrieveItemApiSsoV1ApikeysUidGet', 'uid', uid)
            const localVarPath = `/api/sso/v1/apikeys/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify
         * @param {APIKeyVerifySchema} aPIKeyVerifySchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyApiSsoV1ApikeysVerifyPost: async (aPIKeyVerifySchema: APIKeyVerifySchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'aPIKeyVerifySchema' is not null or undefined
            assertParamExists('verifyApiSsoV1ApikeysVerifyPost', 'aPIKeyVerifySchema', aPIKeyVerifySchema)
            const localVarPath = `/api/sso/v1/apikeys/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aPIKeyVerifySchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIKeyApi - functional programming interface
 */
export const APIKeyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = APIKeyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Item
         * @param {APIKeyCreateSchema} aPIKeyCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemApiSsoV1ApikeysPost(aPIKeyCreateSchema: APIKeyCreateSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIKeyCreateResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemApiSsoV1ApikeysPost(aPIKeyCreateSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIKeyApi.createItemApiSsoV1ApikeysPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemApiSsoV1ApikeysUidDelete(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIKeyResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemApiSsoV1ApikeysUidDelete(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIKeyApi.deleteItemApiSsoV1ApikeysUidDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listItemsApiSsoV1ApikeysGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseAPIKeyResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listItemsApiSsoV1ApikeysGet(offset, limit, createdAtFrom, createdAtTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIKeyApi.listItemsApiSsoV1ApikeysGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveItemApiSsoV1ApikeysUidGet(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIKeyResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveItemApiSsoV1ApikeysUidGet(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIKeyApi.retrieveItemApiSsoV1ApikeysUidGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Verify
         * @param {APIKeyVerifySchema} aPIKeyVerifySchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyApiSsoV1ApikeysVerifyPost(aPIKeyVerifySchema: APIKeyVerifySchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyApiSsoV1ApikeysVerifyPost(aPIKeyVerifySchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIKeyApi.verifyApiSsoV1ApikeysVerifyPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * APIKeyApi - factory interface
 */
export const APIKeyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = APIKeyApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Item
         * @param {APIKeyCreateSchema} aPIKeyCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemApiSsoV1ApikeysPost(aPIKeyCreateSchema: APIKeyCreateSchema, options?: RawAxiosRequestConfig): AxiosPromise<APIKeyCreateResponseSchema> {
            return localVarFp.createItemApiSsoV1ApikeysPost(aPIKeyCreateSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemApiSsoV1ApikeysUidDelete(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<APIKeyResponseSchema> {
            return localVarFp.deleteItemApiSsoV1ApikeysUidDelete(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemsApiSsoV1ApikeysGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseAPIKeyResponseSchema> {
            return localVarFp.listItemsApiSsoV1ApikeysGet(offset, limit, createdAtFrom, createdAtTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveItemApiSsoV1ApikeysUidGet(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<APIKeyResponseSchema> {
            return localVarFp.retrieveItemApiSsoV1ApikeysUidGet(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify
         * @param {APIKeyVerifySchema} aPIKeyVerifySchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyApiSsoV1ApikeysVerifyPost(aPIKeyVerifySchema: APIKeyVerifySchema, options?: RawAxiosRequestConfig): AxiosPromise<UserData> {
            return localVarFp.verifyApiSsoV1ApikeysVerifyPost(aPIKeyVerifySchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * APIKeyApi - object-oriented interface
 */
export class APIKeyApi extends BaseAPI {
    /**
     * 
     * @summary Create Item
     * @param {APIKeyCreateSchema} aPIKeyCreateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createItemApiSsoV1ApikeysPost(aPIKeyCreateSchema: APIKeyCreateSchema, options?: RawAxiosRequestConfig) {
        return APIKeyApiFp(this.configuration).createItemApiSsoV1ApikeysPost(aPIKeyCreateSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Item
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteItemApiSsoV1ApikeysUidDelete(uid: string, options?: RawAxiosRequestConfig) {
        return APIKeyApiFp(this.configuration).deleteItemApiSsoV1ApikeysUidDelete(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Items
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string | null} [createdAtFrom] 
     * @param {string | null} [createdAtTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listItemsApiSsoV1ApikeysGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options?: RawAxiosRequestConfig) {
        return APIKeyApiFp(this.configuration).listItemsApiSsoV1ApikeysGet(offset, limit, createdAtFrom, createdAtTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Item
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveItemApiSsoV1ApikeysUidGet(uid: string, options?: RawAxiosRequestConfig) {
        return APIKeyApiFp(this.configuration).retrieveItemApiSsoV1ApikeysUidGet(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify
     * @param {APIKeyVerifySchema} aPIKeyVerifySchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public verifyApiSsoV1ApikeysVerifyPost(aPIKeyVerifySchema: APIKeyVerifySchema, options?: RawAxiosRequestConfig) {
        return APIKeyApiFp(this.configuration).verifyApiSsoV1ApikeysVerifyPost(aPIKeyVerifySchema, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AgentApi - axios parameter creator
 */
export const AgentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate an agent.
         * @summary Agent Auth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentAuthApiSsoV1AgentsAuthPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/v1/agents/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Item
         * @param {AgentCreateSchema} agentCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemApiSsoV1AgentsPost: async (agentCreateSchema: AgentCreateSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentCreateSchema' is not null or undefined
            assertParamExists('createItemApiSsoV1AgentsPost', 'agentCreateSchema', agentCreateSchema)
            const localVarPath = `/api/sso/v1/agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(agentCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemApiSsoV1AgentsUidDelete: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteItemApiSsoV1AgentsUidDelete', 'uid', uid)
            const localVarPath = `/api/sso/v1/agents/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemsApiSsoV1AgentsGet: async (offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/v1/agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (createdAtFrom !== undefined) {
                localVarQueryParameter['created_at_from'] = (createdAtFrom as any instanceof Date) ?
                    (createdAtFrom as any).toISOString() :
                    createdAtFrom;
            }

            if (createdAtTo !== undefined) {
                localVarQueryParameter['created_at_to'] = (createdAtTo as any instanceof Date) ?
                    (createdAtTo as any).toISOString() :
                    createdAtTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveItemApiSsoV1AgentsUidGet: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('retrieveItemApiSsoV1AgentsUidGet', 'uid', uid)
            const localVarPath = `/api/sso/v1/agents/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Item
         * @param {string} uid 
         * @param {AgentUpdateSchema} agentUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemApiSsoV1AgentsUidPatch: async (uid: string, agentUpdateSchema: AgentUpdateSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateItemApiSsoV1AgentsUidPatch', 'uid', uid)
            // verify required parameter 'agentUpdateSchema' is not null or undefined
            assertParamExists('updateItemApiSsoV1AgentsUidPatch', 'agentUpdateSchema', agentUpdateSchema)
            const localVarPath = `/api/sso/v1/agents/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(agentUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AgentApi - functional programming interface
 */
export const AgentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AgentApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate an agent.
         * @summary Agent Auth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentAuthApiSsoV1AgentsAuthPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentAuthApiSsoV1AgentsAuthPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentApi.agentAuthApiSsoV1AgentsAuthPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Item
         * @param {AgentCreateSchema} agentCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemApiSsoV1AgentsPost(agentCreateSchema: AgentCreateSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemApiSsoV1AgentsPost(agentCreateSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentApi.createItemApiSsoV1AgentsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemApiSsoV1AgentsUidDelete(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemApiSsoV1AgentsUidDelete(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentApi.deleteItemApiSsoV1AgentsUidDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listItemsApiSsoV1AgentsGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseAgentSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listItemsApiSsoV1AgentsGet(offset, limit, createdAtFrom, createdAtTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentApi.listItemsApiSsoV1AgentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveItemApiSsoV1AgentsUidGet(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveItemApiSsoV1AgentsUidGet(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentApi.retrieveItemApiSsoV1AgentsUidGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Item
         * @param {string} uid 
         * @param {AgentUpdateSchema} agentUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItemApiSsoV1AgentsUidPatch(uid: string, agentUpdateSchema: AgentUpdateSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateItemApiSsoV1AgentsUidPatch(uid, agentUpdateSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentApi.updateItemApiSsoV1AgentsUidPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AgentApi - factory interface
 */
export const AgentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AgentApiFp(configuration)
    return {
        /**
         * Authenticate an agent.
         * @summary Agent Auth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentAuthApiSsoV1AgentsAuthPost(options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.agentAuthApiSsoV1AgentsAuthPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Item
         * @param {AgentCreateSchema} agentCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemApiSsoV1AgentsPost(agentCreateSchema: AgentCreateSchema, options?: RawAxiosRequestConfig): AxiosPromise<AgentCreateResponse> {
            return localVarFp.createItemApiSsoV1AgentsPost(agentCreateSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemApiSsoV1AgentsUidDelete(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<AgentSchema> {
            return localVarFp.deleteItemApiSsoV1AgentsUidDelete(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemsApiSsoV1AgentsGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseAgentSchema> {
            return localVarFp.listItemsApiSsoV1AgentsGet(offset, limit, createdAtFrom, createdAtTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveItemApiSsoV1AgentsUidGet(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<AgentSchema> {
            return localVarFp.retrieveItemApiSsoV1AgentsUidGet(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Item
         * @param {string} uid 
         * @param {AgentUpdateSchema} agentUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemApiSsoV1AgentsUidPatch(uid: string, agentUpdateSchema: AgentUpdateSchema, options?: RawAxiosRequestConfig): AxiosPromise<AgentSchema> {
            return localVarFp.updateItemApiSsoV1AgentsUidPatch(uid, agentUpdateSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AgentApi - object-oriented interface
 */
export class AgentApi extends BaseAPI {
    /**
     * Authenticate an agent.
     * @summary Agent Auth
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public agentAuthApiSsoV1AgentsAuthPost(options?: RawAxiosRequestConfig) {
        return AgentApiFp(this.configuration).agentAuthApiSsoV1AgentsAuthPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Item
     * @param {AgentCreateSchema} agentCreateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createItemApiSsoV1AgentsPost(agentCreateSchema: AgentCreateSchema, options?: RawAxiosRequestConfig) {
        return AgentApiFp(this.configuration).createItemApiSsoV1AgentsPost(agentCreateSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Item
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteItemApiSsoV1AgentsUidDelete(uid: string, options?: RawAxiosRequestConfig) {
        return AgentApiFp(this.configuration).deleteItemApiSsoV1AgentsUidDelete(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Items
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string | null} [createdAtFrom] 
     * @param {string | null} [createdAtTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listItemsApiSsoV1AgentsGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options?: RawAxiosRequestConfig) {
        return AgentApiFp(this.configuration).listItemsApiSsoV1AgentsGet(offset, limit, createdAtFrom, createdAtTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Item
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveItemApiSsoV1AgentsUidGet(uid: string, options?: RawAxiosRequestConfig) {
        return AgentApiFp(this.configuration).retrieveItemApiSsoV1AgentsUidGet(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Item
     * @param {string} uid 
     * @param {AgentUpdateSchema} agentUpdateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateItemApiSsoV1AgentsUidPatch(uid: string, agentUpdateSchema: AgentUpdateSchema, options?: RawAxiosRequestConfig) {
        return AgentApiFp(this.configuration).updateItemApiSsoV1AgentsUidPatch(uid, agentUpdateSchema, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthSessionApi - axios parameter creator
 */
export const AuthSessionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Item
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemApiSsoV1SessionsPost: async (requestBody: { [key: string]: any; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('createItemApiSsoV1SessionsPost', 'requestBody', requestBody)
            const localVarPath = `/api/sso/v1/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemApiSsoV1SessionsUidDelete: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteItemApiSsoV1SessionsUidDelete', 'uid', uid)
            const localVarPath = `/api/sso/v1/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {string | null} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemsApiSsoV1SessionsGet: async (offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, userId?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/v1/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (createdAtFrom !== undefined) {
                localVarQueryParameter['created_at_from'] = (createdAtFrom as any instanceof Date) ?
                    (createdAtFrom as any).toISOString() :
                    createdAtFrom;
            }

            if (createdAtTo !== undefined) {
                localVarQueryParameter['created_at_to'] = (createdAtTo as any instanceof Date) ?
                    (createdAtTo as any).toISOString() :
                    createdAtTo;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveItemApiSsoV1SessionsUidGet: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('retrieveItemApiSsoV1SessionsUidGet', 'uid', uid)
            const localVarPath = `/api/sso/v1/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Item
         * @param {string} uid 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemApiSsoV1SessionsUidPatch: async (uid: string, requestBody: { [key: string]: any; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateItemApiSsoV1SessionsUidPatch', 'uid', uid)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('updateItemApiSsoV1SessionsUidPatch', 'requestBody', requestBody)
            const localVarPath = `/api/sso/v1/sessions/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthSessionApi - functional programming interface
 */
export const AuthSessionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthSessionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Item
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemApiSsoV1SessionsPost(requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthSessionSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemApiSsoV1SessionsPost(requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthSessionApi.createItemApiSsoV1SessionsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemApiSsoV1SessionsUidDelete(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthSessionSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemApiSsoV1SessionsUidDelete(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthSessionApi.deleteItemApiSsoV1SessionsUidDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {string | null} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listItemsApiSsoV1SessionsGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, userId?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseAuthSessionSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listItemsApiSsoV1SessionsGet(offset, limit, createdAtFrom, createdAtTo, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthSessionApi.listItemsApiSsoV1SessionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveItemApiSsoV1SessionsUidGet(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthSessionSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveItemApiSsoV1SessionsUidGet(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthSessionApi.retrieveItemApiSsoV1SessionsUidGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Item
         * @param {string} uid 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItemApiSsoV1SessionsUidPatch(uid: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthSessionSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateItemApiSsoV1SessionsUidPatch(uid, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthSessionApi.updateItemApiSsoV1SessionsUidPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthSessionApi - factory interface
 */
export const AuthSessionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthSessionApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Item
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemApiSsoV1SessionsPost(requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): AxiosPromise<AuthSessionSchema> {
            return localVarFp.createItemApiSsoV1SessionsPost(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemApiSsoV1SessionsUidDelete(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<AuthSessionSchema> {
            return localVarFp.deleteItemApiSsoV1SessionsUidDelete(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {string | null} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemsApiSsoV1SessionsGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, userId?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseAuthSessionSchema> {
            return localVarFp.listItemsApiSsoV1SessionsGet(offset, limit, createdAtFrom, createdAtTo, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveItemApiSsoV1SessionsUidGet(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<AuthSessionSchema> {
            return localVarFp.retrieveItemApiSsoV1SessionsUidGet(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Item
         * @param {string} uid 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemApiSsoV1SessionsUidPatch(uid: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): AxiosPromise<AuthSessionSchema> {
            return localVarFp.updateItemApiSsoV1SessionsUidPatch(uid, requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthSessionApi - object-oriented interface
 */
export class AuthSessionApi extends BaseAPI {
    /**
     * 
     * @summary Create Item
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createItemApiSsoV1SessionsPost(requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig) {
        return AuthSessionApiFp(this.configuration).createItemApiSsoV1SessionsPost(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Item
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteItemApiSsoV1SessionsUidDelete(uid: string, options?: RawAxiosRequestConfig) {
        return AuthSessionApiFp(this.configuration).deleteItemApiSsoV1SessionsUidDelete(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Items
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string | null} [createdAtFrom] 
     * @param {string | null} [createdAtTo] 
     * @param {string | null} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listItemsApiSsoV1SessionsGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, userId?: string | null, options?: RawAxiosRequestConfig) {
        return AuthSessionApiFp(this.configuration).listItemsApiSsoV1SessionsGet(offset, limit, createdAtFrom, createdAtTo, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Item
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveItemApiSsoV1SessionsUidGet(uid: string, options?: RawAxiosRequestConfig) {
        return AuthSessionApiFp(this.configuration).retrieveItemApiSsoV1SessionsUidGet(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Item
     * @param {string} uid 
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateItemApiSsoV1SessionsUidPatch(uid: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig) {
        return AuthSessionApiFp(this.configuration).updateItemApiSsoV1SessionsUidPatch(uid, requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthenticationApi - axios parameter creator
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate account.
         * @summary Activate
         * @param {Identifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateApiSsoV1AuthActivatePost: async (identifier: Identifier, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            assertParamExists('activateApiSsoV1AuthActivatePost', 'identifier', identifier)
            const localVarPath = `/api/sso/v1/auth/activate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identifier, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Passkey authentication.
         * @summary Generate Passkey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generatePasskeyApiSsoV1AuthPasskeyGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/v1/auth/passkey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return all routes.
         * @summary Get All Route
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRouteApiSsoV1AuthGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/v1/auth/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User login.
         * @summary Login
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginApiSsoV1AuthLoginPost: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('loginApiSsoV1AuthLoginPost', 'loginRequest', loginRequest)
            const localVarPath = `/api/sso/v1/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User login.
         * @summary Login
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginApiSsoV1AuthLoginPost_1: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('loginApiSsoV1AuthLoginPost_1', 'loginRequest', loginRequest)
            const localVarPath = `/api/sso/v1/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login using magic link.
         * @summary Login By Magic Link
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginByMagicLinkApiSsoV1AuthMagicLinkGet: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('loginByMagicLinkApiSsoV1AuthMagicLinkGet', 'token', token)
            const localVarPath = `/api/sso/v1/auth/magic-link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * End session.
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutApiSsoV1AuthLogoutGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/v1/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * End session.
         * @summary Logout Post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutPostApiSsoV1AuthLogoutPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/v1/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request magic link.
         * @summary Magic Link Request
         * @param {MagicLinkRequest} magicLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        magicLinkRequestApiSsoV1AuthRequestMagicLinkPost: async (magicLinkRequest: MagicLinkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'magicLinkRequest' is not null or undefined
            assertParamExists('magicLinkRequestApiSsoV1AuthRequestMagicLinkPost', 'magicLinkRequest', magicLinkRequest)
            const localVarPath = `/api/sso/v1/auth/request-magic-link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(magicLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request magic link.
         * @summary Magic Link Request
         * @param {MagicLinkRequest} magicLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        magicLinkRequestApiSsoV1AuthRequestMagicLinkPost_2: async (magicLinkRequest: MagicLinkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'magicLinkRequest' is not null or undefined
            assertParamExists('magicLinkRequestApiSsoV1AuthRequestMagicLinkPost_2', 'magicLinkRequest', magicLinkRequest)
            const localVarPath = `/api/sso/v1/auth/request-magic-link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(magicLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Current user info.
         * @summary Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meApiSsoV1AuthMeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/v1/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OAuth authorize.
         * @summary Oauth Authorize
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthAuthorizeApiSsoV1AuthOauthProviderAuthorizeGet: async (provider: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('oauthAuthorizeApiSsoV1AuthOauthProviderAuthorizeGet', 'provider', provider)
            const localVarPath = `/api/sso/v1/auth/oauth/{provider}/authorize`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OAuth callback.
         * @summary Oauth Callback
         * @param {string} provider 
         * @param {string} state 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthCallbackApiSsoV1AuthOauthProviderCallbackGet: async (provider: string, state: string, code: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('oauthCallbackApiSsoV1AuthOauthProviderCallbackGet', 'provider', provider)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('oauthCallbackApiSsoV1AuthOauthProviderCallbackGet', 'state', state)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('oauthCallbackApiSsoV1AuthOauthProviderCallbackGet', 'code', code)
            const localVarPath = `/api/sso/v1/auth/oauth/{provider}/callback`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Passkey authentication.
         * @summary Passkey
         * @param {PasskeyAssertion} passkeyAssertion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyApiSsoV1AuthPasskeyPost: async (passkeyAssertion: PasskeyAssertion, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passkeyAssertion' is not null or undefined
            assertParamExists('passkeyApiSsoV1AuthPasskeyPost', 'passkeyAssertion', passkeyAssertion)
            const localVarPath = `/api/sso/v1/auth/passkey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passkeyAssertion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a new QR code session and return its token.
         * @summary Qr Generate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qrGenerateApiSsoV1AuthQrGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/v1/auth/qr`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a QR session (simulate mobile scan). Update session status and return tokens.
         * @summary Qr Login
         * @param {QRLoginRequest} qRLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qrLoginApiSsoV1AuthQrPost: async (qRLoginRequest: QRLoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'qRLoginRequest' is not null or undefined
            assertParamExists('qrLoginApiSsoV1AuthQrPost', 'qRLoginRequest', qRLoginRequest)
            const localVarPath = `/api/sso/v1/auth/qr`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(qRLoginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check the status of a QR code session. Returns: {status: pending|authenticated|expired, ...}.
         * @summary Qr Status
         * @param {string} qrToken QR session token to check status for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qrStatusApiSsoV1AuthQrStatusGet: async (qrToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'qrToken' is not null or undefined
            assertParamExists('qrStatusApiSsoV1AuthQrStatusGet', 'qrToken', qrToken)
            const localVarPath = `/api/sso/v1/auth/qr/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (qrToken !== undefined) {
                localVarQueryParameter['qr_token'] = qrToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh access token. Use request body to check if the refresh token is valid.
         * @summary Refresh Body
         * @param {RefreshRequest} refreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshBodyApiSsoV1AuthRefreshPost: async (refreshRequest: RefreshRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshRequest' is not null or undefined
            assertParamExists('refreshBodyApiSsoV1AuthRefreshPost', 'refreshRequest', refreshRequest)
            const localVarPath = `/api/sso/v1/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh access token. Use cookie to check if the refresh token is valid.
         * @summary Refresh Cookie
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshCookieApiSsoV1AuthRefreshGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/v1/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request OTP.
         * @summary Request Otp
         * @param {OTPRequest} oTPRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestOtpApiSsoV1AuthRequestOtpPost: async (oTPRequest: OTPRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oTPRequest' is not null or undefined
            assertParamExists('requestOtpApiSsoV1AuthRequestOtpPost', 'oTPRequest', oTPRequest)
            const localVarPath = `/api/sso/v1/auth/request-otp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oTPRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request OTP.
         * @summary Request Otp
         * @param {OTPRequest} oTPRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestOtpApiSsoV1AuthRequestOtpPost_3: async (oTPRequest: OTPRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oTPRequest' is not null or undefined
            assertParamExists('requestOtpApiSsoV1AuthRequestOtpPost_3', 'oTPRequest', oTPRequest)
            const localVarPath = `/api/sso/v1/auth/request-otp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oTPRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Password reset.
         * @summary Reset Password
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordApiSsoV1AuthResetPasswordPost: async (resetPasswordRequest: ResetPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPasswordRequest' is not null or undefined
            assertParamExists('resetPasswordApiSsoV1AuthResetPasswordPost', 'resetPasswordRequest', resetPasswordRequest)
            const localVarPath = `/api/sso/v1/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Password reset.
         * @summary Reset Password
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordApiSsoV1AuthResetPasswordPost_4: async (resetPasswordRequest: ResetPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPasswordRequest' is not null or undefined
            assertParamExists('resetPasswordApiSsoV1AuthResetPasswordPost_4', 'resetPasswordRequest', resetPasswordRequest)
            const localVarPath = `/api/sso/v1/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User login.
         * @summary Signin
         * @param {Data} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinApiSsoV1AuthSigninPost: async (data: Data, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('signinApiSsoV1AuthSigninPost', 'data', data)
            const localVarPath = `/api/sso/v1/auth/signin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify token.
         * @summary Verify Token
         * @param {VerifyTokenRequest} verifyTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyTokenApiSsoV1AuthVerifyTokenPost: async (verifyTokenRequest: VerifyTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyTokenRequest' is not null or undefined
            assertParamExists('verifyTokenApiSsoV1AuthVerifyTokenPost', 'verifyTokenRequest', verifyTokenRequest)
            const localVarPath = `/api/sso/v1/auth/verify-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * Activate account.
         * @summary Activate
         * @param {Identifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateApiSsoV1AuthActivatePost(identifier: Identifier, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateApiSsoV1AuthActivatePost(identifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.activateApiSsoV1AuthActivatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Passkey authentication.
         * @summary Generate Passkey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generatePasskeyApiSsoV1AuthPasskeyGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generatePasskeyApiSsoV1AuthPasskeyGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.generatePasskeyApiSsoV1AuthPasskeyGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return all routes.
         * @summary Get All Route
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRouteApiSsoV1AuthGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string | null>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllRouteApiSsoV1AuthGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.getAllRouteApiSsoV1AuthGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User login.
         * @summary Login
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginApiSsoV1AuthLoginPost(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginApiSsoV1AuthLoginPost(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.loginApiSsoV1AuthLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User login.
         * @summary Login
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginApiSsoV1AuthLoginPost_1(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginApiSsoV1AuthLoginPost_1(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.loginApiSsoV1AuthLoginPost_1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Login using magic link.
         * @summary Login By Magic Link
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginByMagicLinkApiSsoV1AuthMagicLinkGet(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginByMagicLinkApiSsoV1AuthMagicLinkGet(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.loginByMagicLinkApiSsoV1AuthMagicLinkGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * End session.
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutApiSsoV1AuthLogoutGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutApiSsoV1AuthLogoutGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.logoutApiSsoV1AuthLogoutGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * End session.
         * @summary Logout Post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutPostApiSsoV1AuthLogoutPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutPostApiSsoV1AuthLogoutPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.logoutPostApiSsoV1AuthLogoutPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Request magic link.
         * @summary Magic Link Request
         * @param {MagicLinkRequest} magicLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async magicLinkRequestApiSsoV1AuthRequestMagicLinkPost(magicLinkRequest: MagicLinkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.magicLinkRequestApiSsoV1AuthRequestMagicLinkPost(magicLinkRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.magicLinkRequestApiSsoV1AuthRequestMagicLinkPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Request magic link.
         * @summary Magic Link Request
         * @param {MagicLinkRequest} magicLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async magicLinkRequestApiSsoV1AuthRequestMagicLinkPost_2(magicLinkRequest: MagicLinkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.magicLinkRequestApiSsoV1AuthRequestMagicLinkPost_2(magicLinkRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.magicLinkRequestApiSsoV1AuthRequestMagicLinkPost_2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Current user info.
         * @summary Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async meApiSsoV1AuthMeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayloadData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.meApiSsoV1AuthMeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.meApiSsoV1AuthMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * OAuth authorize.
         * @summary Oauth Authorize
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthAuthorizeApiSsoV1AuthOauthProviderAuthorizeGet(provider: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthAuthorizeApiSsoV1AuthOauthProviderAuthorizeGet(provider, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.oauthAuthorizeApiSsoV1AuthOauthProviderAuthorizeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * OAuth callback.
         * @summary Oauth Callback
         * @param {string} provider 
         * @param {string} state 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthCallbackApiSsoV1AuthOauthProviderCallbackGet(provider: string, state: string, code: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthCallbackApiSsoV1AuthOauthProviderCallbackGet(provider, state, code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.oauthCallbackApiSsoV1AuthOauthProviderCallbackGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Passkey authentication.
         * @summary Passkey
         * @param {PasskeyAssertion} passkeyAssertion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passkeyApiSsoV1AuthPasskeyPost(passkeyAssertion: PasskeyAssertion, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passkeyApiSsoV1AuthPasskeyPost(passkeyAssertion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.passkeyApiSsoV1AuthPasskeyPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate a new QR code session and return its token.
         * @summary Qr Generate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qrGenerateApiSsoV1AuthQrGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QRCodeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qrGenerateApiSsoV1AuthQrGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.qrGenerateApiSsoV1AuthQrGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Authenticate a QR session (simulate mobile scan). Update session status and return tokens.
         * @summary Qr Login
         * @param {QRLoginRequest} qRLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qrLoginApiSsoV1AuthQrPost(qRLoginRequest: QRLoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qrLoginApiSsoV1AuthQrPost(qRLoginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.qrLoginApiSsoV1AuthQrPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check the status of a QR code session. Returns: {status: pending|authenticated|expired, ...}.
         * @summary Qr Status
         * @param {string} qrToken QR session token to check status for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qrStatusApiSsoV1AuthQrStatusGet(qrToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qrStatusApiSsoV1AuthQrStatusGet(qrToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.qrStatusApiSsoV1AuthQrStatusGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Refresh access token. Use request body to check if the refresh token is valid.
         * @summary Refresh Body
         * @param {RefreshRequest} refreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshBodyApiSsoV1AuthRefreshPost(refreshRequest: RefreshRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshBodyApiSsoV1AuthRefreshPost(refreshRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.refreshBodyApiSsoV1AuthRefreshPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Refresh access token. Use cookie to check if the refresh token is valid.
         * @summary Refresh Cookie
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshCookieApiSsoV1AuthRefreshGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshCookieApiSsoV1AuthRefreshGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.refreshCookieApiSsoV1AuthRefreshGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Request OTP.
         * @summary Request Otp
         * @param {OTPRequest} oTPRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestOtpApiSsoV1AuthRequestOtpPost(oTPRequest: OTPRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestOtpApiSsoV1AuthRequestOtpPost(oTPRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.requestOtpApiSsoV1AuthRequestOtpPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Request OTP.
         * @summary Request Otp
         * @param {OTPRequest} oTPRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestOtpApiSsoV1AuthRequestOtpPost_3(oTPRequest: OTPRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestOtpApiSsoV1AuthRequestOtpPost_3(oTPRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.requestOtpApiSsoV1AuthRequestOtpPost_3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Password reset.
         * @summary Reset Password
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPasswordApiSsoV1AuthResetPasswordPost(resetPasswordRequest: ResetPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPasswordApiSsoV1AuthResetPasswordPost(resetPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.resetPasswordApiSsoV1AuthResetPasswordPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Password reset.
         * @summary Reset Password
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPasswordApiSsoV1AuthResetPasswordPost_4(resetPasswordRequest: ResetPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPasswordApiSsoV1AuthResetPasswordPost_4(resetPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.resetPasswordApiSsoV1AuthResetPasswordPost_4']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User login.
         * @summary Signin
         * @param {Data} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signinApiSsoV1AuthSigninPost(data: Data, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signinApiSsoV1AuthSigninPost(data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.signinApiSsoV1AuthSigninPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verify token.
         * @summary Verify Token
         * @param {VerifyTokenRequest} verifyTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyTokenApiSsoV1AuthVerifyTokenPost(verifyTokenRequest: VerifyTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayloadData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyTokenApiSsoV1AuthVerifyTokenPost(verifyTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.verifyTokenApiSsoV1AuthVerifyTokenPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * Activate account.
         * @summary Activate
         * @param {Identifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateApiSsoV1AuthActivatePost(identifier: Identifier, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.activateApiSsoV1AuthActivatePost(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Passkey authentication.
         * @summary Generate Passkey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generatePasskeyApiSsoV1AuthPasskeyGet(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.generatePasskeyApiSsoV1AuthPasskeyGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Return all routes.
         * @summary Get All Route
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRouteApiSsoV1AuthGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<string | null>> {
            return localVarFp.getAllRouteApiSsoV1AuthGet(options).then((request) => request(axios, basePath));
        },
        /**
         * User login.
         * @summary Login
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginApiSsoV1AuthLoginPost(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.loginApiSsoV1AuthLoginPost(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * User login.
         * @summary Login
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginApiSsoV1AuthLoginPost_1(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.loginApiSsoV1AuthLoginPost_1(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Login using magic link.
         * @summary Login By Magic Link
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginByMagicLinkApiSsoV1AuthMagicLinkGet(token: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.loginByMagicLinkApiSsoV1AuthMagicLinkGet(token, options).then((request) => request(axios, basePath));
        },
        /**
         * End session.
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutApiSsoV1AuthLogoutGet(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logoutApiSsoV1AuthLogoutGet(options).then((request) => request(axios, basePath));
        },
        /**
         * End session.
         * @summary Logout Post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutPostApiSsoV1AuthLogoutPost(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logoutPostApiSsoV1AuthLogoutPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Request magic link.
         * @summary Magic Link Request
         * @param {MagicLinkRequest} magicLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        magicLinkRequestApiSsoV1AuthRequestMagicLinkPost(magicLinkRequest: MagicLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.magicLinkRequestApiSsoV1AuthRequestMagicLinkPost(magicLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Request magic link.
         * @summary Magic Link Request
         * @param {MagicLinkRequest} magicLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        magicLinkRequestApiSsoV1AuthRequestMagicLinkPost_2(magicLinkRequest: MagicLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.magicLinkRequestApiSsoV1AuthRequestMagicLinkPost_2(magicLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Current user info.
         * @summary Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meApiSsoV1AuthMeGet(options?: RawAxiosRequestConfig): AxiosPromise<PayloadData> {
            return localVarFp.meApiSsoV1AuthMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * OAuth authorize.
         * @summary Oauth Authorize
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthAuthorizeApiSsoV1AuthOauthProviderAuthorizeGet(provider: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.oauthAuthorizeApiSsoV1AuthOauthProviderAuthorizeGet(provider, options).then((request) => request(axios, basePath));
        },
        /**
         * OAuth callback.
         * @summary Oauth Callback
         * @param {string} provider 
         * @param {string} state 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthCallbackApiSsoV1AuthOauthProviderCallbackGet(provider: string, state: string, code: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.oauthCallbackApiSsoV1AuthOauthProviderCallbackGet(provider, state, code, options).then((request) => request(axios, basePath));
        },
        /**
         * Passkey authentication.
         * @summary Passkey
         * @param {PasskeyAssertion} passkeyAssertion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyApiSsoV1AuthPasskeyPost(passkeyAssertion: PasskeyAssertion, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.passkeyApiSsoV1AuthPasskeyPost(passkeyAssertion, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a new QR code session and return its token.
         * @summary Qr Generate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qrGenerateApiSsoV1AuthQrGet(options?: RawAxiosRequestConfig): AxiosPromise<QRCodeResponse> {
            return localVarFp.qrGenerateApiSsoV1AuthQrGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a QR session (simulate mobile scan). Update session status and return tokens.
         * @summary Qr Login
         * @param {QRLoginRequest} qRLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qrLoginApiSsoV1AuthQrPost(qRLoginRequest: QRLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<RefreshResponse> {
            return localVarFp.qrLoginApiSsoV1AuthQrPost(qRLoginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Check the status of a QR code session. Returns: {status: pending|authenticated|expired, ...}.
         * @summary Qr Status
         * @param {string} qrToken QR session token to check status for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qrStatusApiSsoV1AuthQrStatusGet(qrToken: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.qrStatusApiSsoV1AuthQrStatusGet(qrToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh access token. Use request body to check if the refresh token is valid.
         * @summary Refresh Body
         * @param {RefreshRequest} refreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshBodyApiSsoV1AuthRefreshPost(refreshRequest: RefreshRequest, options?: RawAxiosRequestConfig): AxiosPromise<RefreshResponse> {
            return localVarFp.refreshBodyApiSsoV1AuthRefreshPost(refreshRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh access token. Use cookie to check if the refresh token is valid.
         * @summary Refresh Cookie
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshCookieApiSsoV1AuthRefreshGet(options?: RawAxiosRequestConfig): AxiosPromise<RefreshResponse> {
            return localVarFp.refreshCookieApiSsoV1AuthRefreshGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Request OTP.
         * @summary Request Otp
         * @param {OTPRequest} oTPRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestOtpApiSsoV1AuthRequestOtpPost(oTPRequest: OTPRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.requestOtpApiSsoV1AuthRequestOtpPost(oTPRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Request OTP.
         * @summary Request Otp
         * @param {OTPRequest} oTPRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestOtpApiSsoV1AuthRequestOtpPost_3(oTPRequest: OTPRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.requestOtpApiSsoV1AuthRequestOtpPost_3(oTPRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Password reset.
         * @summary Reset Password
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordApiSsoV1AuthResetPasswordPost(resetPasswordRequest: ResetPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.resetPasswordApiSsoV1AuthResetPasswordPost(resetPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Password reset.
         * @summary Reset Password
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordApiSsoV1AuthResetPasswordPost_4(resetPasswordRequest: ResetPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.resetPasswordApiSsoV1AuthResetPasswordPost_4(resetPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * User login.
         * @summary Signin
         * @param {Data} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinApiSsoV1AuthSigninPost(data: Data, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.signinApiSsoV1AuthSigninPost(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify token.
         * @summary Verify Token
         * @param {VerifyTokenRequest} verifyTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyTokenApiSsoV1AuthVerifyTokenPost(verifyTokenRequest: VerifyTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<PayloadData> {
            return localVarFp.verifyTokenApiSsoV1AuthVerifyTokenPost(verifyTokenRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * Activate account.
     * @summary Activate
     * @param {Identifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public activateApiSsoV1AuthActivatePost(identifier: Identifier, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).activateApiSsoV1AuthActivatePost(identifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Passkey authentication.
     * @summary Generate Passkey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public generatePasskeyApiSsoV1AuthPasskeyGet(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).generatePasskeyApiSsoV1AuthPasskeyGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return all routes.
     * @summary Get All Route
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllRouteApiSsoV1AuthGet(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).getAllRouteApiSsoV1AuthGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User login.
     * @summary Login
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public loginApiSsoV1AuthLoginPost(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).loginApiSsoV1AuthLoginPost(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User login.
     * @summary Login
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public loginApiSsoV1AuthLoginPost_1(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).loginApiSsoV1AuthLoginPost_1(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Login using magic link.
     * @summary Login By Magic Link
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public loginByMagicLinkApiSsoV1AuthMagicLinkGet(token: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).loginByMagicLinkApiSsoV1AuthMagicLinkGet(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * End session.
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public logoutApiSsoV1AuthLogoutGet(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).logoutApiSsoV1AuthLogoutGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * End session.
     * @summary Logout Post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public logoutPostApiSsoV1AuthLogoutPost(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).logoutPostApiSsoV1AuthLogoutPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request magic link.
     * @summary Magic Link Request
     * @param {MagicLinkRequest} magicLinkRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public magicLinkRequestApiSsoV1AuthRequestMagicLinkPost(magicLinkRequest: MagicLinkRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).magicLinkRequestApiSsoV1AuthRequestMagicLinkPost(magicLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request magic link.
     * @summary Magic Link Request
     * @param {MagicLinkRequest} magicLinkRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public magicLinkRequestApiSsoV1AuthRequestMagicLinkPost_2(magicLinkRequest: MagicLinkRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).magicLinkRequestApiSsoV1AuthRequestMagicLinkPost_2(magicLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Current user info.
     * @summary Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public meApiSsoV1AuthMeGet(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).meApiSsoV1AuthMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * OAuth authorize.
     * @summary Oauth Authorize
     * @param {string} provider 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public oauthAuthorizeApiSsoV1AuthOauthProviderAuthorizeGet(provider: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).oauthAuthorizeApiSsoV1AuthOauthProviderAuthorizeGet(provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * OAuth callback.
     * @summary Oauth Callback
     * @param {string} provider 
     * @param {string} state 
     * @param {string} code 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public oauthCallbackApiSsoV1AuthOauthProviderCallbackGet(provider: string, state: string, code: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).oauthCallbackApiSsoV1AuthOauthProviderCallbackGet(provider, state, code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Passkey authentication.
     * @summary Passkey
     * @param {PasskeyAssertion} passkeyAssertion 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public passkeyApiSsoV1AuthPasskeyPost(passkeyAssertion: PasskeyAssertion, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).passkeyApiSsoV1AuthPasskeyPost(passkeyAssertion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a new QR code session and return its token.
     * @summary Qr Generate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public qrGenerateApiSsoV1AuthQrGet(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).qrGenerateApiSsoV1AuthQrGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a QR session (simulate mobile scan). Update session status and return tokens.
     * @summary Qr Login
     * @param {QRLoginRequest} qRLoginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public qrLoginApiSsoV1AuthQrPost(qRLoginRequest: QRLoginRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).qrLoginApiSsoV1AuthQrPost(qRLoginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check the status of a QR code session. Returns: {status: pending|authenticated|expired, ...}.
     * @summary Qr Status
     * @param {string} qrToken QR session token to check status for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public qrStatusApiSsoV1AuthQrStatusGet(qrToken: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).qrStatusApiSsoV1AuthQrStatusGet(qrToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh access token. Use request body to check if the refresh token is valid.
     * @summary Refresh Body
     * @param {RefreshRequest} refreshRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public refreshBodyApiSsoV1AuthRefreshPost(refreshRequest: RefreshRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).refreshBodyApiSsoV1AuthRefreshPost(refreshRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh access token. Use cookie to check if the refresh token is valid.
     * @summary Refresh Cookie
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public refreshCookieApiSsoV1AuthRefreshGet(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).refreshCookieApiSsoV1AuthRefreshGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request OTP.
     * @summary Request Otp
     * @param {OTPRequest} oTPRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public requestOtpApiSsoV1AuthRequestOtpPost(oTPRequest: OTPRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).requestOtpApiSsoV1AuthRequestOtpPost(oTPRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request OTP.
     * @summary Request Otp
     * @param {OTPRequest} oTPRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public requestOtpApiSsoV1AuthRequestOtpPost_3(oTPRequest: OTPRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).requestOtpApiSsoV1AuthRequestOtpPost_3(oTPRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Password reset.
     * @summary Reset Password
     * @param {ResetPasswordRequest} resetPasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resetPasswordApiSsoV1AuthResetPasswordPost(resetPasswordRequest: ResetPasswordRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).resetPasswordApiSsoV1AuthResetPasswordPost(resetPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Password reset.
     * @summary Reset Password
     * @param {ResetPasswordRequest} resetPasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resetPasswordApiSsoV1AuthResetPasswordPost_4(resetPasswordRequest: ResetPasswordRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).resetPasswordApiSsoV1AuthResetPasswordPost_4(resetPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User login.
     * @summary Signin
     * @param {Data} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public signinApiSsoV1AuthSigninPost(data: Data, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).signinApiSsoV1AuthSigninPost(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify token.
     * @summary Verify Token
     * @param {VerifyTokenRequest} verifyTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public verifyTokenApiSsoV1AuthVerifyTokenPost(verifyTokenRequest: VerifyTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).verifyTokenApiSsoV1AuthVerifyTokenPost(verifyTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CaptchaApi - axios parameter creator
 */
export const CaptchaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Challenge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChallengeApiSsoV1CaptchaChallengeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/v1/captcha/challenge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify the captcha payload and return status with input data.
         * @summary Verify
         * @param {BodyVerifyApiSsoV1CaptchaVerifyPost} [bodyVerifyApiSsoV1CaptchaVerifyPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyApiSsoV1CaptchaVerifyPost: async (bodyVerifyApiSsoV1CaptchaVerifyPost?: BodyVerifyApiSsoV1CaptchaVerifyPost, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/v1/captcha/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyVerifyApiSsoV1CaptchaVerifyPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CaptchaApi - functional programming interface
 */
export const CaptchaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CaptchaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Challenge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChallengeApiSsoV1CaptchaChallengeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChallengeApiSsoV1CaptchaChallengeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaptchaApi.getChallengeApiSsoV1CaptchaChallengeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verify the captcha payload and return status with input data.
         * @summary Verify
         * @param {BodyVerifyApiSsoV1CaptchaVerifyPost} [bodyVerifyApiSsoV1CaptchaVerifyPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyApiSsoV1CaptchaVerifyPost(bodyVerifyApiSsoV1CaptchaVerifyPost?: BodyVerifyApiSsoV1CaptchaVerifyPost, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyApiSsoV1CaptchaVerifyPost(bodyVerifyApiSsoV1CaptchaVerifyPost, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaptchaApi.verifyApiSsoV1CaptchaVerifyPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CaptchaApi - factory interface
 */
export const CaptchaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CaptchaApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Challenge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChallengeApiSsoV1CaptchaChallengeGet(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.getChallengeApiSsoV1CaptchaChallengeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Verify the captcha payload and return status with input data.
         * @summary Verify
         * @param {BodyVerifyApiSsoV1CaptchaVerifyPost} [bodyVerifyApiSsoV1CaptchaVerifyPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyApiSsoV1CaptchaVerifyPost(bodyVerifyApiSsoV1CaptchaVerifyPost?: BodyVerifyApiSsoV1CaptchaVerifyPost, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.verifyApiSsoV1CaptchaVerifyPost(bodyVerifyApiSsoV1CaptchaVerifyPost, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CaptchaApi - object-oriented interface
 */
export class CaptchaApi extends BaseAPI {
    /**
     * 
     * @summary Get Challenge
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getChallengeApiSsoV1CaptchaChallengeGet(options?: RawAxiosRequestConfig) {
        return CaptchaApiFp(this.configuration).getChallengeApiSsoV1CaptchaChallengeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify the captcha payload and return status with input data.
     * @summary Verify
     * @param {BodyVerifyApiSsoV1CaptchaVerifyPost} [bodyVerifyApiSsoV1CaptchaVerifyPost] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public verifyApiSsoV1CaptchaVerifyPost(bodyVerifyApiSsoV1CaptchaVerifyPost?: BodyVerifyApiSsoV1CaptchaVerifyPost, options?: RawAxiosRequestConfig) {
        return CaptchaApiFp(this.configuration).verifyApiSsoV1CaptchaVerifyPost(bodyVerifyApiSsoV1CaptchaVerifyPost, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CredentialsApi - axios parameter creator
 */
export const CredentialsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Item
         * @param {CredentialCreateSchema} credentialCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemApiSsoV1CredentialsPost: async (credentialCreateSchema: CredentialCreateSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentialCreateSchema' is not null or undefined
            assertParamExists('createItemApiSsoV1CredentialsPost', 'credentialCreateSchema', credentialCreateSchema)
            const localVarPath = `/api/sso/v1/credentials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(credentialCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Webauthn Credential
         * @param {PasskeyAssertion} passkeyAssertion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebauthnCredentialApiSsoV1CredentialsWebauthnPost: async (passkeyAssertion: PasskeyAssertion, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passkeyAssertion' is not null or undefined
            assertParamExists('createWebauthnCredentialApiSsoV1CredentialsWebauthnPost', 'passkeyAssertion', passkeyAssertion)
            const localVarPath = `/api/sso/v1/credentials/webauthn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passkeyAssertion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemApiSsoV1CredentialsUidDelete: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteItemApiSsoV1CredentialsUidDelete', 'uid', uid)
            const localVarPath = `/api/sso/v1/credentials/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate webauthn challenge for new passkey registration
         * @summary Get Webauthn Challenge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebauthnChallengeApiSsoV1CredentialsWebauthnGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/v1/credentials/webauthn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemsApiSsoV1CredentialsGet: async (offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/v1/credentials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveItemApiSsoV1CredentialsUidGet: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('retrieveItemApiSsoV1CredentialsUidGet', 'uid', uid)
            const localVarPath = `/api/sso/v1/credentials/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CredentialsApi - functional programming interface
 */
export const CredentialsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CredentialsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Item
         * @param {CredentialCreateSchema} credentialCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemApiSsoV1CredentialsPost(credentialCreateSchema: CredentialCreateSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemApiSsoV1CredentialsPost(credentialCreateSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CredentialsApi.createItemApiSsoV1CredentialsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Webauthn Credential
         * @param {PasskeyAssertion} passkeyAssertion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWebauthnCredentialApiSsoV1CredentialsWebauthnPost(passkeyAssertion: PasskeyAssertion, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWebauthnCredentialApiSsoV1CredentialsWebauthnPost(passkeyAssertion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CredentialsApi.createWebauthnCredentialApiSsoV1CredentialsWebauthnPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemApiSsoV1CredentialsUidDelete(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemApiSsoV1CredentialsUidDelete(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CredentialsApi.deleteItemApiSsoV1CredentialsUidDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate webauthn challenge for new passkey registration
         * @summary Get Webauthn Challenge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebauthnChallengeApiSsoV1CredentialsWebauthnGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebauthnChallengeApiSsoV1CredentialsWebauthnGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CredentialsApi.getWebauthnChallengeApiSsoV1CredentialsWebauthnGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listItemsApiSsoV1CredentialsGet(offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseCredentialResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listItemsApiSsoV1CredentialsGet(offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CredentialsApi.listItemsApiSsoV1CredentialsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveItemApiSsoV1CredentialsUidGet(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveItemApiSsoV1CredentialsUidGet(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CredentialsApi.retrieveItemApiSsoV1CredentialsUidGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CredentialsApi - factory interface
 */
export const CredentialsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CredentialsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Item
         * @param {CredentialCreateSchema} credentialCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemApiSsoV1CredentialsPost(credentialCreateSchema: CredentialCreateSchema, options?: RawAxiosRequestConfig): AxiosPromise<CredentialResponseSchema> {
            return localVarFp.createItemApiSsoV1CredentialsPost(credentialCreateSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Webauthn Credential
         * @param {PasskeyAssertion} passkeyAssertion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebauthnCredentialApiSsoV1CredentialsWebauthnPost(passkeyAssertion: PasskeyAssertion, options?: RawAxiosRequestConfig): AxiosPromise<CredentialResponseSchema> {
            return localVarFp.createWebauthnCredentialApiSsoV1CredentialsWebauthnPost(passkeyAssertion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemApiSsoV1CredentialsUidDelete(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<CredentialResponseSchema> {
            return localVarFp.deleteItemApiSsoV1CredentialsUidDelete(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate webauthn challenge for new passkey registration
         * @summary Get Webauthn Challenge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebauthnChallengeApiSsoV1CredentialsWebauthnGet(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.getWebauthnChallengeApiSsoV1CredentialsWebauthnGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemsApiSsoV1CredentialsGet(offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseCredentialResponseSchema> {
            return localVarFp.listItemsApiSsoV1CredentialsGet(offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveItemApiSsoV1CredentialsUidGet(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<CredentialResponseSchema> {
            return localVarFp.retrieveItemApiSsoV1CredentialsUidGet(uid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CredentialsApi - object-oriented interface
 */
export class CredentialsApi extends BaseAPI {
    /**
     * 
     * @summary Create Item
     * @param {CredentialCreateSchema} credentialCreateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createItemApiSsoV1CredentialsPost(credentialCreateSchema: CredentialCreateSchema, options?: RawAxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).createItemApiSsoV1CredentialsPost(credentialCreateSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Webauthn Credential
     * @param {PasskeyAssertion} passkeyAssertion 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createWebauthnCredentialApiSsoV1CredentialsWebauthnPost(passkeyAssertion: PasskeyAssertion, options?: RawAxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).createWebauthnCredentialApiSsoV1CredentialsWebauthnPost(passkeyAssertion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Item
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteItemApiSsoV1CredentialsUidDelete(uid: string, options?: RawAxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).deleteItemApiSsoV1CredentialsUidDelete(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate webauthn challenge for new passkey registration
     * @summary Get Webauthn Challenge
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWebauthnChallengeApiSsoV1CredentialsWebauthnGet(options?: RawAxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).getWebauthnChallengeApiSsoV1CredentialsWebauthnGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Items
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listItemsApiSsoV1CredentialsGet(offset?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).listItemsApiSsoV1CredentialsGet(offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Item
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveItemApiSsoV1CredentialsUidGet(uid: string, options?: RawAxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).retrieveItemApiSsoV1CredentialsUidGet(uid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthApiSsoV1HealthGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/v1/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthApiSsoV1HealthGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthApiSsoV1HealthGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.healthApiSsoV1HealthGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthApiSsoV1HealthGet(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.healthApiSsoV1HealthGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public healthApiSsoV1HealthGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).healthApiSsoV1HealthGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GatewayRouteApi - axios parameter creator
 */
export const GatewayRouteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Item
         * @param {GatewayRouteCreateSchema} gatewayRouteCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemApiSsoV1GatewayroutesPost: async (gatewayRouteCreateSchema: GatewayRouteCreateSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gatewayRouteCreateSchema' is not null or undefined
            assertParamExists('createItemApiSsoV1GatewayroutesPost', 'gatewayRouteCreateSchema', gatewayRouteCreateSchema)
            const localVarPath = `/api/sso/v1/gatewayroutes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gatewayRouteCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemApiSsoV1GatewayroutesUidDelete: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteItemApiSsoV1GatewayroutesUidDelete', 'uid', uid)
            const localVarPath = `/api/sso/v1/gatewayroutes/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemsApiSsoV1GatewayroutesGet: async (offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/v1/gatewayroutes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (createdAtFrom !== undefined) {
                localVarQueryParameter['created_at_from'] = (createdAtFrom as any instanceof Date) ?
                    (createdAtFrom as any).toISOString() :
                    createdAtFrom;
            }

            if (createdAtTo !== undefined) {
                localVarQueryParameter['created_at_to'] = (createdAtTo as any instanceof Date) ?
                    (createdAtTo as any).toISOString() :
                    createdAtTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveItemApiSsoV1GatewayroutesUidGet: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('retrieveItemApiSsoV1GatewayroutesUidGet', 'uid', uid)
            const localVarPath = `/api/sso/v1/gatewayroutes/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Item
         * @param {string} uid 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemApiSsoV1GatewayroutesUidPatch: async (uid: string, requestBody: { [key: string]: any; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateItemApiSsoV1GatewayroutesUidPatch', 'uid', uid)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('updateItemApiSsoV1GatewayroutesUidPatch', 'requestBody', requestBody)
            const localVarPath = `/api/sso/v1/gatewayroutes/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GatewayRouteApi - functional programming interface
 */
export const GatewayRouteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GatewayRouteApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Item
         * @param {GatewayRouteCreateSchema} gatewayRouteCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemApiSsoV1GatewayroutesPost(gatewayRouteCreateSchema: GatewayRouteCreateSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatewayRouteSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemApiSsoV1GatewayroutesPost(gatewayRouteCreateSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GatewayRouteApi.createItemApiSsoV1GatewayroutesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemApiSsoV1GatewayroutesUidDelete(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatewayRouteSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemApiSsoV1GatewayroutesUidDelete(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GatewayRouteApi.deleteItemApiSsoV1GatewayroutesUidDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listItemsApiSsoV1GatewayroutesGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseGatewayRouteSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listItemsApiSsoV1GatewayroutesGet(offset, limit, createdAtFrom, createdAtTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GatewayRouteApi.listItemsApiSsoV1GatewayroutesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveItemApiSsoV1GatewayroutesUidGet(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatewayRouteSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveItemApiSsoV1GatewayroutesUidGet(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GatewayRouteApi.retrieveItemApiSsoV1GatewayroutesUidGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Item
         * @param {string} uid 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItemApiSsoV1GatewayroutesUidPatch(uid: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatewayRouteSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateItemApiSsoV1GatewayroutesUidPatch(uid, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GatewayRouteApi.updateItemApiSsoV1GatewayroutesUidPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GatewayRouteApi - factory interface
 */
export const GatewayRouteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GatewayRouteApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Item
         * @param {GatewayRouteCreateSchema} gatewayRouteCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemApiSsoV1GatewayroutesPost(gatewayRouteCreateSchema: GatewayRouteCreateSchema, options?: RawAxiosRequestConfig): AxiosPromise<GatewayRouteSchema> {
            return localVarFp.createItemApiSsoV1GatewayroutesPost(gatewayRouteCreateSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemApiSsoV1GatewayroutesUidDelete(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<GatewayRouteSchema> {
            return localVarFp.deleteItemApiSsoV1GatewayroutesUidDelete(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemsApiSsoV1GatewayroutesGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseGatewayRouteSchema> {
            return localVarFp.listItemsApiSsoV1GatewayroutesGet(offset, limit, createdAtFrom, createdAtTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveItemApiSsoV1GatewayroutesUidGet(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<GatewayRouteSchema> {
            return localVarFp.retrieveItemApiSsoV1GatewayroutesUidGet(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Item
         * @param {string} uid 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemApiSsoV1GatewayroutesUidPatch(uid: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): AxiosPromise<GatewayRouteSchema> {
            return localVarFp.updateItemApiSsoV1GatewayroutesUidPatch(uid, requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GatewayRouteApi - object-oriented interface
 */
export class GatewayRouteApi extends BaseAPI {
    /**
     * 
     * @summary Create Item
     * @param {GatewayRouteCreateSchema} gatewayRouteCreateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createItemApiSsoV1GatewayroutesPost(gatewayRouteCreateSchema: GatewayRouteCreateSchema, options?: RawAxiosRequestConfig) {
        return GatewayRouteApiFp(this.configuration).createItemApiSsoV1GatewayroutesPost(gatewayRouteCreateSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Item
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteItemApiSsoV1GatewayroutesUidDelete(uid: string, options?: RawAxiosRequestConfig) {
        return GatewayRouteApiFp(this.configuration).deleteItemApiSsoV1GatewayroutesUidDelete(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Items
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string | null} [createdAtFrom] 
     * @param {string | null} [createdAtTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listItemsApiSsoV1GatewayroutesGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options?: RawAxiosRequestConfig) {
        return GatewayRouteApiFp(this.configuration).listItemsApiSsoV1GatewayroutesGet(offset, limit, createdAtFrom, createdAtTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Item
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveItemApiSsoV1GatewayroutesUidGet(uid: string, options?: RawAxiosRequestConfig) {
        return GatewayRouteApiFp(this.configuration).retrieveItemApiSsoV1GatewayroutesUidGet(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Item
     * @param {string} uid 
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateItemApiSsoV1GatewayroutesUidPatch(uid: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig) {
        return GatewayRouteApiFp(this.configuration).updateItemApiSsoV1GatewayroutesUidPatch(uid, requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IdentifiersApi - axios parameter creator
 */
export const IdentifiersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Item
         * @param {UserIdentifierCreateSchema} userIdentifierCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemApiSsoV1IdentifiersPost: async (userIdentifierCreateSchema: UserIdentifierCreateSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userIdentifierCreateSchema' is not null or undefined
            assertParamExists('createItemApiSsoV1IdentifiersPost', 'userIdentifierCreateSchema', userIdentifierCreateSchema)
            const localVarPath = `/api/sso/v1/identifiers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userIdentifierCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemApiSsoV1IdentifiersUidDelete: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteItemApiSsoV1IdentifiersUidDelete', 'uid', uid)
            const localVarPath = `/api/sso/v1/identifiers/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemsApiSsoV1IdentifiersGet: async (offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/v1/identifiers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (createdAtFrom !== undefined) {
                localVarQueryParameter['created_at_from'] = (createdAtFrom as any instanceof Date) ?
                    (createdAtFrom as any).toISOString() :
                    createdAtFrom;
            }

            if (createdAtTo !== undefined) {
                localVarQueryParameter['created_at_to'] = (createdAtTo as any instanceof Date) ?
                    (createdAtTo as any).toISOString() :
                    createdAtTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveItemApiSsoV1IdentifiersUidGet: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('retrieveItemApiSsoV1IdentifiersUidGet', 'uid', uid)
            const localVarPath = `/api/sso/v1/identifiers/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdentifiersApi - functional programming interface
 */
export const IdentifiersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdentifiersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Item
         * @param {UserIdentifierCreateSchema} userIdentifierCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemApiSsoV1IdentifiersPost(userIdentifierCreateSchema: UserIdentifierCreateSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserIdentifierSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemApiSsoV1IdentifiersPost(userIdentifierCreateSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentifiersApi.createItemApiSsoV1IdentifiersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemApiSsoV1IdentifiersUidDelete(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserIdentifierSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemApiSsoV1IdentifiersUidDelete(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentifiersApi.deleteItemApiSsoV1IdentifiersUidDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listItemsApiSsoV1IdentifiersGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseUserIdentifierSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listItemsApiSsoV1IdentifiersGet(offset, limit, createdAtFrom, createdAtTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentifiersApi.listItemsApiSsoV1IdentifiersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveItemApiSsoV1IdentifiersUidGet(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserIdentifierSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveItemApiSsoV1IdentifiersUidGet(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentifiersApi.retrieveItemApiSsoV1IdentifiersUidGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IdentifiersApi - factory interface
 */
export const IdentifiersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdentifiersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Item
         * @param {UserIdentifierCreateSchema} userIdentifierCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemApiSsoV1IdentifiersPost(userIdentifierCreateSchema: UserIdentifierCreateSchema, options?: RawAxiosRequestConfig): AxiosPromise<UserIdentifierSchema> {
            return localVarFp.createItemApiSsoV1IdentifiersPost(userIdentifierCreateSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemApiSsoV1IdentifiersUidDelete(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<UserIdentifierSchema> {
            return localVarFp.deleteItemApiSsoV1IdentifiersUidDelete(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemsApiSsoV1IdentifiersGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseUserIdentifierSchema> {
            return localVarFp.listItemsApiSsoV1IdentifiersGet(offset, limit, createdAtFrom, createdAtTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveItemApiSsoV1IdentifiersUidGet(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<UserIdentifierSchema> {
            return localVarFp.retrieveItemApiSsoV1IdentifiersUidGet(uid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdentifiersApi - object-oriented interface
 */
export class IdentifiersApi extends BaseAPI {
    /**
     * 
     * @summary Create Item
     * @param {UserIdentifierCreateSchema} userIdentifierCreateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createItemApiSsoV1IdentifiersPost(userIdentifierCreateSchema: UserIdentifierCreateSchema, options?: RawAxiosRequestConfig) {
        return IdentifiersApiFp(this.configuration).createItemApiSsoV1IdentifiersPost(userIdentifierCreateSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Item
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteItemApiSsoV1IdentifiersUidDelete(uid: string, options?: RawAxiosRequestConfig) {
        return IdentifiersApiFp(this.configuration).deleteItemApiSsoV1IdentifiersUidDelete(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Items
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string | null} [createdAtFrom] 
     * @param {string | null} [createdAtTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listItemsApiSsoV1IdentifiersGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options?: RawAxiosRequestConfig) {
        return IdentifiersApiFp(this.configuration).listItemsApiSsoV1IdentifiersGet(offset, limit, createdAtFrom, createdAtTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Item
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveItemApiSsoV1IdentifiersUidGet(uid: string, options?: RawAxiosRequestConfig) {
        return IdentifiersApiFp(this.configuration).retrieveItemApiSsoV1IdentifiersUidGet(uid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IntegrationApi - axios parameter creator
 */
export const IntegrationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get JSON Web Key Set (JWKS) for token verification.
         * @summary Get Jwks
         * @param {string | null} [domain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJwksWellKnownJwksJsonGet: async (domain?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/.well-known/jwks.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (domain !== undefined) {
                localVarQueryParameter['domain'] = domain;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get OpenID Connect configuration.
         * @summary Get Openid Configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenidConfigurationWellKnownOpenidConfigurationGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/.well-known/openid-configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntegrationApi - functional programming interface
 */
export const IntegrationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IntegrationApiAxiosParamCreator(configuration)
    return {
        /**
         * Get JSON Web Key Set (JWKS) for token verification.
         * @summary Get Jwks
         * @param {string | null} [domain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJwksWellKnownJwksJsonGet(domain?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: Array<{ [key: string]: ResponseGetJwksWellKnownJwksJsonGetValueInnerValue; }>; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJwksWellKnownJwksJsonGet(domain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationApi.getJwksWellKnownJwksJsonGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get OpenID Connect configuration.
         * @summary Get Openid Configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenidConfigurationWellKnownOpenidConfigurationGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: ResponseGetOpenidConfigurationWellKnownOpenidConfigurationGetValue; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenidConfigurationWellKnownOpenidConfigurationGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationApi.getOpenidConfigurationWellKnownOpenidConfigurationGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IntegrationApi - factory interface
 */
export const IntegrationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IntegrationApiFp(configuration)
    return {
        /**
         * Get JSON Web Key Set (JWKS) for token verification.
         * @summary Get Jwks
         * @param {string | null} [domain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJwksWellKnownJwksJsonGet(domain?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: Array<{ [key: string]: ResponseGetJwksWellKnownJwksJsonGetValueInnerValue; }>; }> {
            return localVarFp.getJwksWellKnownJwksJsonGet(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Get OpenID Connect configuration.
         * @summary Get Openid Configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenidConfigurationWellKnownOpenidConfigurationGet(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: ResponseGetOpenidConfigurationWellKnownOpenidConfigurationGetValue; }> {
            return localVarFp.getOpenidConfigurationWellKnownOpenidConfigurationGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IntegrationApi - object-oriented interface
 */
export class IntegrationApi extends BaseAPI {
    /**
     * Get JSON Web Key Set (JWKS) for token verification.
     * @summary Get Jwks
     * @param {string | null} [domain] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getJwksWellKnownJwksJsonGet(domain?: string | null, options?: RawAxiosRequestConfig) {
        return IntegrationApiFp(this.configuration).getJwksWellKnownJwksJsonGet(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get OpenID Connect configuration.
     * @summary Get Openid Configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getOpenidConfigurationWellKnownOpenidConfigurationGet(options?: RawAxiosRequestConfig) {
        return IntegrationApiFp(this.configuration).getOpenidConfigurationWellKnownOpenidConfigurationGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OAuth2OIDCApi - axios parameter creator
 */
export const OAuth2OIDCApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * OAuth2 Authorization endpoint.
         * @summary Authorize
         * @param {ResponseType} responseType Response type
         * @param {string} clientId Client identifier
         * @param {string} redirectUri Redirect URI
         * @param {string | null} [scope] Requested scopes
         * @param {string | null} [state] State parameter
         * @param {string | null} [codeChallenge] PKCE code challenge
         * @param {string | null} [codeChallengeMethod] PKCE code challenge method
         * @param {string | null} [nonce] Nonce for ID token
         * @param {string | null} [prompt] Prompt parameter
         * @param {number | null} [maxAge] Maximum authentication age
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeApiSsoV1OauthAuthorizeGet: async (responseType: ResponseType, clientId: string, redirectUri: string, scope?: string | null, state?: string | null, codeChallenge?: string | null, codeChallengeMethod?: string | null, nonce?: string | null, prompt?: string | null, maxAge?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'responseType' is not null or undefined
            assertParamExists('authorizeApiSsoV1OauthAuthorizeGet', 'responseType', responseType)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('authorizeApiSsoV1OauthAuthorizeGet', 'clientId', clientId)
            // verify required parameter 'redirectUri' is not null or undefined
            assertParamExists('authorizeApiSsoV1OauthAuthorizeGet', 'redirectUri', redirectUri)
            const localVarPath = `/api/sso/v1/oauth/authorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (responseType !== undefined) {
                localVarQueryParameter['response_type'] = responseType;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['client_id'] = clientId;
            }

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (codeChallenge !== undefined) {
                localVarQueryParameter['code_challenge'] = codeChallenge;
            }

            if (codeChallengeMethod !== undefined) {
                localVarQueryParameter['code_challenge_method'] = codeChallengeMethod;
            }

            if (nonce !== undefined) {
                localVarQueryParameter['nonce'] = nonce;
            }

            if (prompt !== undefined) {
                localVarQueryParameter['prompt'] = prompt;
            }

            if (maxAge !== undefined) {
                localVarQueryParameter['max_age'] = maxAge;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OAuth2 Consent endpoint.
         * @summary Consent Authorize
         * @param {boolean} consent User consent
         * @param {string} [state] State parameter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentAuthorizeApiSsoV1OauthConsentPost: async (consent: boolean, state?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consent' is not null or undefined
            assertParamExists('consentAuthorizeApiSsoV1OauthConsentPost', 'consent', consent)
            const localVarPath = `/api/sso/v1/oauth/consent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (consent !== undefined) {
                localVarQueryParameter['consent'] = consent;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete/deactivate OAuth2 client (REST Level 2).
         * @summary Delete Client
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClientApiSsoV1OauthClientsClientIdDelete: async (clientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('deleteClientApiSsoV1OauthClientsClientIdDelete', 'clientId', clientId)
            const localVarPath = `/api/sso/v1/oauth/clients/{client_id}`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get OAuth2 client information.
         * @summary Get Client
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientApiSsoV1OauthClientsClientIdGet: async (clientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('getClientApiSsoV1OauthClientsClientIdGet', 'clientId', clientId)
            const localVarPath = `/api/sso/v1/oauth/clients/{client_id}`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Consent Authorize
         * @param {boolean} consent User consent
         * @param {string} [state] State parameter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentAuthorizeApiSsoV1OauthConsentGet: async (consent: boolean, state?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consent' is not null or undefined
            assertParamExists('getConsentAuthorizeApiSsoV1OauthConsentGet', 'consent', consent)
            const localVarPath = `/api/sso/v1/oauth/consent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (consent !== undefined) {
                localVarQueryParameter['consent'] = consent;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OAuth2 Token Introspection endpoint.
         * @summary Introspect
         * @param {string} token Token to introspect
         * @param {string} clientId Client identifier
         * @param {string | null} [tokenTypeHint] 
         * @param {string | null} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        introspectApiSsoV1OauthIntrospectPost: async (token: string, clientId: string, tokenTypeHint?: string | null, clientSecret?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('introspectApiSsoV1OauthIntrospectPost', 'token', token)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('introspectApiSsoV1OauthIntrospectPost', 'clientId', clientId)
            const localVarPath = `/api/sso/v1/oauth/introspect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (token !== undefined) { 
                localVarFormParams.set('token', token as any);
            }
    
            if (tokenTypeHint !== undefined) { 
                localVarFormParams.set('token_type_hint', tokenTypeHint as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List OAuth2 clients (REST Level 2).
         * @summary List Clients
         * @param {boolean | null} [isActive] Filter by active status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClientsApiSsoV1OauthClientsGet: async (isActive?: boolean | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/v1/oauth/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OAuth2 Dynamic Client Registration endpoint.
         * @summary Register Client Endpoint
         * @param {ClientRegistrationRequestSchema} clientRegistrationRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerClientEndpointApiSsoV1OauthClientsPost: async (clientRegistrationRequestSchema: ClientRegistrationRequestSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientRegistrationRequestSchema' is not null or undefined
            assertParamExists('registerClientEndpointApiSsoV1OauthClientsPost', 'clientRegistrationRequestSchema', clientRegistrationRequestSchema)
            const localVarPath = `/api/sso/v1/oauth/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientRegistrationRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OAuth2 Token Revocation endpoint.
         * @summary Revoke
         * @param {string} token Token to revoke
         * @param {string} clientId Client identifier
         * @param {string | null} [tokenTypeHint] 
         * @param {string | null} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeApiSsoV1OauthRevokePost: async (token: string, clientId: string, tokenTypeHint?: string | null, clientSecret?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('revokeApiSsoV1OauthRevokePost', 'token', token)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('revokeApiSsoV1OauthRevokePost', 'clientId', clientId)
            const localVarPath = `/api/sso/v1/oauth/revoke`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (token !== undefined) { 
                localVarFormParams.set('token', token as any);
            }
    
            if (tokenTypeHint !== undefined) { 
                localVarFormParams.set('token_type_hint', tokenTypeHint as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rotate OAuth2 client secret (REST Level 2).
         * @summary Rotate Client Secret
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rotateClientSecretApiSsoV1OauthClientsClientIdRotateSecretPost: async (clientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('rotateClientSecretApiSsoV1OauthClientsClientIdRotateSecretPost', 'clientId', clientId)
            const localVarPath = `/api/sso/v1/oauth/clients/{client_id}/rotate-secret`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OAuth2 Token endpoint.
         * @summary Token
         * @param {GrantType} grantType Grant type
         * @param {string | null} [clientId] 
         * @param {string | null} [clientSecret] 
         * @param {string | null} [code] 
         * @param {string | null} [redirectUri] 
         * @param {string | null} [codeVerifier] 
         * @param {string | null} [refreshToken] 
         * @param {string | null} [scope] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenApiSsoV1OauthTokenPost: async (grantType: GrantType, clientId?: string | null, clientSecret?: string | null, code?: string | null, redirectUri?: string | null, codeVerifier?: string | null, refreshToken?: string | null, scope?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'grantType' is not null or undefined
            assertParamExists('tokenApiSsoV1OauthTokenPost', 'grantType', grantType)
            const localVarPath = `/api/sso/v1/oauth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
            if (code !== undefined) { 
                localVarFormParams.set('code', code as any);
            }
    
            if (redirectUri !== undefined) { 
                localVarFormParams.set('redirect_uri', redirectUri as any);
            }
    
            if (codeVerifier !== undefined) { 
                localVarFormParams.set('code_verifier', codeVerifier as any);
            }
    
            if (refreshToken !== undefined) { 
                localVarFormParams.set('refresh_token', refreshToken as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update OAuth2 client (REST Level 2).
         * @summary Update Client
         * @param {string} clientId 
         * @param {ClientUpdateSchema} clientUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClientApiSsoV1OauthClientsClientIdPatch: async (clientId: string, clientUpdateSchema: ClientUpdateSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('updateClientApiSsoV1OauthClientsClientIdPatch', 'clientId', clientId)
            // verify required parameter 'clientUpdateSchema' is not null or undefined
            assertParamExists('updateClientApiSsoV1OauthClientsClientIdPatch', 'clientUpdateSchema', clientUpdateSchema)
            const localVarPath = `/api/sso/v1/oauth/clients/{client_id}`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OpenID Connect UserInfo endpoint.
         * @summary Userinfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userinfoApiSsoV1OauthUserinfoGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/v1/oauth/userinfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OAuth2OIDCApi - functional programming interface
 */
export const OAuth2OIDCApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OAuth2OIDCApiAxiosParamCreator(configuration)
    return {
        /**
         * OAuth2 Authorization endpoint.
         * @summary Authorize
         * @param {ResponseType} responseType Response type
         * @param {string} clientId Client identifier
         * @param {string} redirectUri Redirect URI
         * @param {string | null} [scope] Requested scopes
         * @param {string | null} [state] State parameter
         * @param {string | null} [codeChallenge] PKCE code challenge
         * @param {string | null} [codeChallengeMethod] PKCE code challenge method
         * @param {string | null} [nonce] Nonce for ID token
         * @param {string | null} [prompt] Prompt parameter
         * @param {number | null} [maxAge] Maximum authentication age
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorizeApiSsoV1OauthAuthorizeGet(responseType: ResponseType, clientId: string, redirectUri: string, scope?: string | null, state?: string | null, codeChallenge?: string | null, codeChallengeMethod?: string | null, nonce?: string | null, prompt?: string | null, maxAge?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorizeApiSsoV1OauthAuthorizeGet(responseType, clientId, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, maxAge, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuth2OIDCApi.authorizeApiSsoV1OauthAuthorizeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * OAuth2 Consent endpoint.
         * @summary Consent Authorize
         * @param {boolean} consent User consent
         * @param {string} [state] State parameter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consentAuthorizeApiSsoV1OauthConsentPost(consent: boolean, state?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consentAuthorizeApiSsoV1OauthConsentPost(consent, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuth2OIDCApi.consentAuthorizeApiSsoV1OauthConsentPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete/deactivate OAuth2 client (REST Level 2).
         * @summary Delete Client
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteClientApiSsoV1OauthClientsClientIdDelete(clientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteClientApiSsoV1OauthClientsClientIdDelete(clientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuth2OIDCApi.deleteClientApiSsoV1OauthClientsClientIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get OAuth2 client information.
         * @summary Get Client
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClientApiSsoV1OauthClientsClientIdGet(clientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientRegistrationResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClientApiSsoV1OauthClientsClientIdGet(clientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuth2OIDCApi.getClientApiSsoV1OauthClientsClientIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Consent Authorize
         * @param {boolean} consent User consent
         * @param {string} [state] State parameter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConsentAuthorizeApiSsoV1OauthConsentGet(consent: boolean, state?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConsentAuthorizeApiSsoV1OauthConsentGet(consent, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuth2OIDCApi.getConsentAuthorizeApiSsoV1OauthConsentGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * OAuth2 Token Introspection endpoint.
         * @summary Introspect
         * @param {string} token Token to introspect
         * @param {string} clientId Client identifier
         * @param {string | null} [tokenTypeHint] 
         * @param {string | null} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async introspectApiSsoV1OauthIntrospectPost(token: string, clientId: string, tokenTypeHint?: string | null, clientSecret?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenIntrospectionResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.introspectApiSsoV1OauthIntrospectPost(token, clientId, tokenTypeHint, clientSecret, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuth2OIDCApi.introspectApiSsoV1OauthIntrospectPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List OAuth2 clients (REST Level 2).
         * @summary List Clients
         * @param {boolean | null} [isActive] Filter by active status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listClientsApiSsoV1OauthClientsGet(isActive?: boolean | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClientRegistrationResponseSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listClientsApiSsoV1OauthClientsGet(isActive, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuth2OIDCApi.listClientsApiSsoV1OauthClientsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * OAuth2 Dynamic Client Registration endpoint.
         * @summary Register Client Endpoint
         * @param {ClientRegistrationRequestSchema} clientRegistrationRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerClientEndpointApiSsoV1OauthClientsPost(clientRegistrationRequestSchema: ClientRegistrationRequestSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientRegistrationResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerClientEndpointApiSsoV1OauthClientsPost(clientRegistrationRequestSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuth2OIDCApi.registerClientEndpointApiSsoV1OauthClientsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * OAuth2 Token Revocation endpoint.
         * @summary Revoke
         * @param {string} token Token to revoke
         * @param {string} clientId Client identifier
         * @param {string | null} [tokenTypeHint] 
         * @param {string | null} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeApiSsoV1OauthRevokePost(token: string, clientId: string, tokenTypeHint?: string | null, clientSecret?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string | null; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeApiSsoV1OauthRevokePost(token, clientId, tokenTypeHint, clientSecret, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuth2OIDCApi.revokeApiSsoV1OauthRevokePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Rotate OAuth2 client secret (REST Level 2).
         * @summary Rotate Client Secret
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rotateClientSecretApiSsoV1OauthClientsClientIdRotateSecretPost(clientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string | null; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rotateClientSecretApiSsoV1OauthClientsClientIdRotateSecretPost(clientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuth2OIDCApi.rotateClientSecretApiSsoV1OauthClientsClientIdRotateSecretPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * OAuth2 Token endpoint.
         * @summary Token
         * @param {GrantType} grantType Grant type
         * @param {string | null} [clientId] 
         * @param {string | null} [clientSecret] 
         * @param {string | null} [code] 
         * @param {string | null} [redirectUri] 
         * @param {string | null} [codeVerifier] 
         * @param {string | null} [refreshToken] 
         * @param {string | null} [scope] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenApiSsoV1OauthTokenPost(grantType: GrantType, clientId?: string | null, clientSecret?: string | null, code?: string | null, redirectUri?: string | null, codeVerifier?: string | null, refreshToken?: string | null, scope?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenApiSsoV1OauthTokenPost(grantType, clientId, clientSecret, code, redirectUri, codeVerifier, refreshToken, scope, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuth2OIDCApi.tokenApiSsoV1OauthTokenPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update OAuth2 client (REST Level 2).
         * @summary Update Client
         * @param {string} clientId 
         * @param {ClientUpdateSchema} clientUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateClientApiSsoV1OauthClientsClientIdPatch(clientId: string, clientUpdateSchema: ClientUpdateSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientRegistrationResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateClientApiSsoV1OauthClientsClientIdPatch(clientId, clientUpdateSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuth2OIDCApi.updateClientApiSsoV1OauthClientsClientIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * OpenID Connect UserInfo endpoint.
         * @summary Userinfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userinfoApiSsoV1OauthUserinfoGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfoResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userinfoApiSsoV1OauthUserinfoGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuth2OIDCApi.userinfoApiSsoV1OauthUserinfoGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OAuth2OIDCApi - factory interface
 */
export const OAuth2OIDCApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OAuth2OIDCApiFp(configuration)
    return {
        /**
         * OAuth2 Authorization endpoint.
         * @summary Authorize
         * @param {ResponseType} responseType Response type
         * @param {string} clientId Client identifier
         * @param {string} redirectUri Redirect URI
         * @param {string | null} [scope] Requested scopes
         * @param {string | null} [state] State parameter
         * @param {string | null} [codeChallenge] PKCE code challenge
         * @param {string | null} [codeChallengeMethod] PKCE code challenge method
         * @param {string | null} [nonce] Nonce for ID token
         * @param {string | null} [prompt] Prompt parameter
         * @param {number | null} [maxAge] Maximum authentication age
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeApiSsoV1OauthAuthorizeGet(responseType: ResponseType, clientId: string, redirectUri: string, scope?: string | null, state?: string | null, codeChallenge?: string | null, codeChallengeMethod?: string | null, nonce?: string | null, prompt?: string | null, maxAge?: number | null, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.authorizeApiSsoV1OauthAuthorizeGet(responseType, clientId, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, maxAge, options).then((request) => request(axios, basePath));
        },
        /**
         * OAuth2 Consent endpoint.
         * @summary Consent Authorize
         * @param {boolean} consent User consent
         * @param {string} [state] State parameter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentAuthorizeApiSsoV1OauthConsentPost(consent: boolean, state?: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.consentAuthorizeApiSsoV1OauthConsentPost(consent, state, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete/deactivate OAuth2 client (REST Level 2).
         * @summary Delete Client
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClientApiSsoV1OauthClientsClientIdDelete(clientId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteClientApiSsoV1OauthClientsClientIdDelete(clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get OAuth2 client information.
         * @summary Get Client
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientApiSsoV1OauthClientsClientIdGet(clientId: string, options?: RawAxiosRequestConfig): AxiosPromise<ClientRegistrationResponseSchema> {
            return localVarFp.getClientApiSsoV1OauthClientsClientIdGet(clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Consent Authorize
         * @param {boolean} consent User consent
         * @param {string} [state] State parameter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentAuthorizeApiSsoV1OauthConsentGet(consent: boolean, state?: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getConsentAuthorizeApiSsoV1OauthConsentGet(consent, state, options).then((request) => request(axios, basePath));
        },
        /**
         * OAuth2 Token Introspection endpoint.
         * @summary Introspect
         * @param {string} token Token to introspect
         * @param {string} clientId Client identifier
         * @param {string | null} [tokenTypeHint] 
         * @param {string | null} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        introspectApiSsoV1OauthIntrospectPost(token: string, clientId: string, tokenTypeHint?: string | null, clientSecret?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<TokenIntrospectionResponseSchema> {
            return localVarFp.introspectApiSsoV1OauthIntrospectPost(token, clientId, tokenTypeHint, clientSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * List OAuth2 clients (REST Level 2).
         * @summary List Clients
         * @param {boolean | null} [isActive] Filter by active status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClientsApiSsoV1OauthClientsGet(isActive?: boolean | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<ClientRegistrationResponseSchema>> {
            return localVarFp.listClientsApiSsoV1OauthClientsGet(isActive, options).then((request) => request(axios, basePath));
        },
        /**
         * OAuth2 Dynamic Client Registration endpoint.
         * @summary Register Client Endpoint
         * @param {ClientRegistrationRequestSchema} clientRegistrationRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerClientEndpointApiSsoV1OauthClientsPost(clientRegistrationRequestSchema: ClientRegistrationRequestSchema, options?: RawAxiosRequestConfig): AxiosPromise<ClientRegistrationResponseSchema> {
            return localVarFp.registerClientEndpointApiSsoV1OauthClientsPost(clientRegistrationRequestSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * OAuth2 Token Revocation endpoint.
         * @summary Revoke
         * @param {string} token Token to revoke
         * @param {string} clientId Client identifier
         * @param {string | null} [tokenTypeHint] 
         * @param {string | null} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeApiSsoV1OauthRevokePost(token: string, clientId: string, tokenTypeHint?: string | null, clientSecret?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string | null; }> {
            return localVarFp.revokeApiSsoV1OauthRevokePost(token, clientId, tokenTypeHint, clientSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * Rotate OAuth2 client secret (REST Level 2).
         * @summary Rotate Client Secret
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rotateClientSecretApiSsoV1OauthClientsClientIdRotateSecretPost(clientId: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string | null; }> {
            return localVarFp.rotateClientSecretApiSsoV1OauthClientsClientIdRotateSecretPost(clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * OAuth2 Token endpoint.
         * @summary Token
         * @param {GrantType} grantType Grant type
         * @param {string | null} [clientId] 
         * @param {string | null} [clientSecret] 
         * @param {string | null} [code] 
         * @param {string | null} [redirectUri] 
         * @param {string | null} [codeVerifier] 
         * @param {string | null} [refreshToken] 
         * @param {string | null} [scope] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenApiSsoV1OauthTokenPost(grantType: GrantType, clientId?: string | null, clientSecret?: string | null, code?: string | null, redirectUri?: string | null, codeVerifier?: string | null, refreshToken?: string | null, scope?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<TokenResponseSchema> {
            return localVarFp.tokenApiSsoV1OauthTokenPost(grantType, clientId, clientSecret, code, redirectUri, codeVerifier, refreshToken, scope, options).then((request) => request(axios, basePath));
        },
        /**
         * Update OAuth2 client (REST Level 2).
         * @summary Update Client
         * @param {string} clientId 
         * @param {ClientUpdateSchema} clientUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClientApiSsoV1OauthClientsClientIdPatch(clientId: string, clientUpdateSchema: ClientUpdateSchema, options?: RawAxiosRequestConfig): AxiosPromise<ClientRegistrationResponseSchema> {
            return localVarFp.updateClientApiSsoV1OauthClientsClientIdPatch(clientId, clientUpdateSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * OpenID Connect UserInfo endpoint.
         * @summary Userinfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userinfoApiSsoV1OauthUserinfoGet(options?: RawAxiosRequestConfig): AxiosPromise<UserInfoResponseSchema> {
            return localVarFp.userinfoApiSsoV1OauthUserinfoGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OAuth2OIDCApi - object-oriented interface
 */
export class OAuth2OIDCApi extends BaseAPI {
    /**
     * OAuth2 Authorization endpoint.
     * @summary Authorize
     * @param {ResponseType} responseType Response type
     * @param {string} clientId Client identifier
     * @param {string} redirectUri Redirect URI
     * @param {string | null} [scope] Requested scopes
     * @param {string | null} [state] State parameter
     * @param {string | null} [codeChallenge] PKCE code challenge
     * @param {string | null} [codeChallengeMethod] PKCE code challenge method
     * @param {string | null} [nonce] Nonce for ID token
     * @param {string | null} [prompt] Prompt parameter
     * @param {number | null} [maxAge] Maximum authentication age
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authorizeApiSsoV1OauthAuthorizeGet(responseType: ResponseType, clientId: string, redirectUri: string, scope?: string | null, state?: string | null, codeChallenge?: string | null, codeChallengeMethod?: string | null, nonce?: string | null, prompt?: string | null, maxAge?: number | null, options?: RawAxiosRequestConfig) {
        return OAuth2OIDCApiFp(this.configuration).authorizeApiSsoV1OauthAuthorizeGet(responseType, clientId, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, maxAge, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * OAuth2 Consent endpoint.
     * @summary Consent Authorize
     * @param {boolean} consent User consent
     * @param {string} [state] State parameter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public consentAuthorizeApiSsoV1OauthConsentPost(consent: boolean, state?: string, options?: RawAxiosRequestConfig) {
        return OAuth2OIDCApiFp(this.configuration).consentAuthorizeApiSsoV1OauthConsentPost(consent, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete/deactivate OAuth2 client (REST Level 2).
     * @summary Delete Client
     * @param {string} clientId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteClientApiSsoV1OauthClientsClientIdDelete(clientId: string, options?: RawAxiosRequestConfig) {
        return OAuth2OIDCApiFp(this.configuration).deleteClientApiSsoV1OauthClientsClientIdDelete(clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get OAuth2 client information.
     * @summary Get Client
     * @param {string} clientId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getClientApiSsoV1OauthClientsClientIdGet(clientId: string, options?: RawAxiosRequestConfig) {
        return OAuth2OIDCApiFp(this.configuration).getClientApiSsoV1OauthClientsClientIdGet(clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Consent Authorize
     * @param {boolean} consent User consent
     * @param {string} [state] State parameter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getConsentAuthorizeApiSsoV1OauthConsentGet(consent: boolean, state?: string, options?: RawAxiosRequestConfig) {
        return OAuth2OIDCApiFp(this.configuration).getConsentAuthorizeApiSsoV1OauthConsentGet(consent, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * OAuth2 Token Introspection endpoint.
     * @summary Introspect
     * @param {string} token Token to introspect
     * @param {string} clientId Client identifier
     * @param {string | null} [tokenTypeHint] 
     * @param {string | null} [clientSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public introspectApiSsoV1OauthIntrospectPost(token: string, clientId: string, tokenTypeHint?: string | null, clientSecret?: string | null, options?: RawAxiosRequestConfig) {
        return OAuth2OIDCApiFp(this.configuration).introspectApiSsoV1OauthIntrospectPost(token, clientId, tokenTypeHint, clientSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List OAuth2 clients (REST Level 2).
     * @summary List Clients
     * @param {boolean | null} [isActive] Filter by active status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listClientsApiSsoV1OauthClientsGet(isActive?: boolean | null, options?: RawAxiosRequestConfig) {
        return OAuth2OIDCApiFp(this.configuration).listClientsApiSsoV1OauthClientsGet(isActive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * OAuth2 Dynamic Client Registration endpoint.
     * @summary Register Client Endpoint
     * @param {ClientRegistrationRequestSchema} clientRegistrationRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public registerClientEndpointApiSsoV1OauthClientsPost(clientRegistrationRequestSchema: ClientRegistrationRequestSchema, options?: RawAxiosRequestConfig) {
        return OAuth2OIDCApiFp(this.configuration).registerClientEndpointApiSsoV1OauthClientsPost(clientRegistrationRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * OAuth2 Token Revocation endpoint.
     * @summary Revoke
     * @param {string} token Token to revoke
     * @param {string} clientId Client identifier
     * @param {string | null} [tokenTypeHint] 
     * @param {string | null} [clientSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public revokeApiSsoV1OauthRevokePost(token: string, clientId: string, tokenTypeHint?: string | null, clientSecret?: string | null, options?: RawAxiosRequestConfig) {
        return OAuth2OIDCApiFp(this.configuration).revokeApiSsoV1OauthRevokePost(token, clientId, tokenTypeHint, clientSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rotate OAuth2 client secret (REST Level 2).
     * @summary Rotate Client Secret
     * @param {string} clientId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rotateClientSecretApiSsoV1OauthClientsClientIdRotateSecretPost(clientId: string, options?: RawAxiosRequestConfig) {
        return OAuth2OIDCApiFp(this.configuration).rotateClientSecretApiSsoV1OauthClientsClientIdRotateSecretPost(clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * OAuth2 Token endpoint.
     * @summary Token
     * @param {GrantType} grantType Grant type
     * @param {string | null} [clientId] 
     * @param {string | null} [clientSecret] 
     * @param {string | null} [code] 
     * @param {string | null} [redirectUri] 
     * @param {string | null} [codeVerifier] 
     * @param {string | null} [refreshToken] 
     * @param {string | null} [scope] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tokenApiSsoV1OauthTokenPost(grantType: GrantType, clientId?: string | null, clientSecret?: string | null, code?: string | null, redirectUri?: string | null, codeVerifier?: string | null, refreshToken?: string | null, scope?: string | null, options?: RawAxiosRequestConfig) {
        return OAuth2OIDCApiFp(this.configuration).tokenApiSsoV1OauthTokenPost(grantType, clientId, clientSecret, code, redirectUri, codeVerifier, refreshToken, scope, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update OAuth2 client (REST Level 2).
     * @summary Update Client
     * @param {string} clientId 
     * @param {ClientUpdateSchema} clientUpdateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateClientApiSsoV1OauthClientsClientIdPatch(clientId: string, clientUpdateSchema: ClientUpdateSchema, options?: RawAxiosRequestConfig) {
        return OAuth2OIDCApiFp(this.configuration).updateClientApiSsoV1OauthClientsClientIdPatch(clientId, clientUpdateSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * OpenID Connect UserInfo endpoint.
     * @summary Userinfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userinfoApiSsoV1OauthUserinfoGet(options?: RawAxiosRequestConfig) {
        return OAuth2OIDCApiFp(this.configuration).userinfoApiSsoV1OauthUserinfoGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProfileApi - axios parameter creator
 */
export const ProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Item
         * @param {ProfileCreateSchema} profileCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemApiSsoV1ProfilesPost: async (profileCreateSchema: ProfileCreateSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileCreateSchema' is not null or undefined
            assertParamExists('createItemApiSsoV1ProfilesPost', 'profileCreateSchema', profileCreateSchema)
            const localVarPath = `/api/sso/v1/profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profileCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemApiSsoV1ProfilesUidDelete: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteItemApiSsoV1ProfilesUidDelete', 'uid', uid)
            const localVarPath = `/api/sso/v1/profiles/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemsApiSsoV1ProfilesGet: async (offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/v1/profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (createdAtFrom !== undefined) {
                localVarQueryParameter['created_at_from'] = (createdAtFrom as any instanceof Date) ?
                    (createdAtFrom as any).toISOString() :
                    createdAtFrom;
            }

            if (createdAtTo !== undefined) {
                localVarQueryParameter['created_at_to'] = (createdAtTo as any instanceof Date) ?
                    (createdAtTo as any).toISOString() :
                    createdAtTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mine Items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mineItemsApiSsoV1ProfilesMineGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/v1/profiles/mine`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveItemApiSsoV1ProfilesUidGet: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('retrieveItemApiSsoV1ProfilesUidGet', 'uid', uid)
            const localVarPath = `/api/sso/v1/profiles/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Item
         * @param {string} uid 
         * @param {ProfileUpdateSchema} profileUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemApiSsoV1ProfilesUidPatch: async (uid: string, profileUpdateSchema: ProfileUpdateSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateItemApiSsoV1ProfilesUidPatch', 'uid', uid)
            // verify required parameter 'profileUpdateSchema' is not null or undefined
            assertParamExists('updateItemApiSsoV1ProfilesUidPatch', 'profileUpdateSchema', profileUpdateSchema)
            const localVarPath = `/api/sso/v1/profiles/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profileUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Mine Items
         * @param {ProfileUpdateSchema} profileUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMineItemsApiSsoV1ProfilesMinePatch: async (profileUpdateSchema: ProfileUpdateSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileUpdateSchema' is not null or undefined
            assertParamExists('updateMineItemsApiSsoV1ProfilesMinePatch', 'profileUpdateSchema', profileUpdateSchema)
            const localVarPath = `/api/sso/v1/profiles/mine`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profileUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileApi - functional programming interface
 */
export const ProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Item
         * @param {ProfileCreateSchema} profileCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemApiSsoV1ProfilesPost(profileCreateSchema: ProfileCreateSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemApiSsoV1ProfilesPost(profileCreateSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.createItemApiSsoV1ProfilesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemApiSsoV1ProfilesUidDelete(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemApiSsoV1ProfilesUidDelete(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.deleteItemApiSsoV1ProfilesUidDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listItemsApiSsoV1ProfilesGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseProfileSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listItemsApiSsoV1ProfilesGet(offset, limit, createdAtFrom, createdAtTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.listItemsApiSsoV1ProfilesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Mine Items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mineItemsApiSsoV1ProfilesMineGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mineItemsApiSsoV1ProfilesMineGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.mineItemsApiSsoV1ProfilesMineGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveItemApiSsoV1ProfilesUidGet(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveItemApiSsoV1ProfilesUidGet(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.retrieveItemApiSsoV1ProfilesUidGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Item
         * @param {string} uid 
         * @param {ProfileUpdateSchema} profileUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItemApiSsoV1ProfilesUidPatch(uid: string, profileUpdateSchema: ProfileUpdateSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateItemApiSsoV1ProfilesUidPatch(uid, profileUpdateSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.updateItemApiSsoV1ProfilesUidPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Mine Items
         * @param {ProfileUpdateSchema} profileUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMineItemsApiSsoV1ProfilesMinePatch(profileUpdateSchema: ProfileUpdateSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMineItemsApiSsoV1ProfilesMinePatch(profileUpdateSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.updateMineItemsApiSsoV1ProfilesMinePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProfileApi - factory interface
 */
export const ProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Item
         * @param {ProfileCreateSchema} profileCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemApiSsoV1ProfilesPost(profileCreateSchema: ProfileCreateSchema, options?: RawAxiosRequestConfig): AxiosPromise<ProfileSchema> {
            return localVarFp.createItemApiSsoV1ProfilesPost(profileCreateSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemApiSsoV1ProfilesUidDelete(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<ProfileSchema> {
            return localVarFp.deleteItemApiSsoV1ProfilesUidDelete(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemsApiSsoV1ProfilesGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseProfileSchema> {
            return localVarFp.listItemsApiSsoV1ProfilesGet(offset, limit, createdAtFrom, createdAtTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mine Items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mineItemsApiSsoV1ProfilesMineGet(options?: RawAxiosRequestConfig): AxiosPromise<ProfileSchema> {
            return localVarFp.mineItemsApiSsoV1ProfilesMineGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveItemApiSsoV1ProfilesUidGet(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<ProfileSchema> {
            return localVarFp.retrieveItemApiSsoV1ProfilesUidGet(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Item
         * @param {string} uid 
         * @param {ProfileUpdateSchema} profileUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemApiSsoV1ProfilesUidPatch(uid: string, profileUpdateSchema: ProfileUpdateSchema, options?: RawAxiosRequestConfig): AxiosPromise<ProfileSchema> {
            return localVarFp.updateItemApiSsoV1ProfilesUidPatch(uid, profileUpdateSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Mine Items
         * @param {ProfileUpdateSchema} profileUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMineItemsApiSsoV1ProfilesMinePatch(profileUpdateSchema: ProfileUpdateSchema, options?: RawAxiosRequestConfig): AxiosPromise<ProfileSchema> {
            return localVarFp.updateMineItemsApiSsoV1ProfilesMinePatch(profileUpdateSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfileApi - object-oriented interface
 */
export class ProfileApi extends BaseAPI {
    /**
     * 
     * @summary Create Item
     * @param {ProfileCreateSchema} profileCreateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createItemApiSsoV1ProfilesPost(profileCreateSchema: ProfileCreateSchema, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).createItemApiSsoV1ProfilesPost(profileCreateSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Item
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteItemApiSsoV1ProfilesUidDelete(uid: string, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).deleteItemApiSsoV1ProfilesUidDelete(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Items
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string | null} [createdAtFrom] 
     * @param {string | null} [createdAtTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listItemsApiSsoV1ProfilesGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).listItemsApiSsoV1ProfilesGet(offset, limit, createdAtFrom, createdAtTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mine Items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mineItemsApiSsoV1ProfilesMineGet(options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).mineItemsApiSsoV1ProfilesMineGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Item
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveItemApiSsoV1ProfilesUidGet(uid: string, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).retrieveItemApiSsoV1ProfilesUidGet(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Item
     * @param {string} uid 
     * @param {ProfileUpdateSchema} profileUpdateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateItemApiSsoV1ProfilesUidPatch(uid: string, profileUpdateSchema: ProfileUpdateSchema, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).updateItemApiSsoV1ProfilesUidPatch(uid, profileUpdateSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Mine Items
     * @param {ProfileUpdateSchema} profileUpdateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateMineItemsApiSsoV1ProfilesMinePatch(profileUpdateSchema: ProfileUpdateSchema, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).updateMineItemsApiSsoV1ProfilesMinePatch(profileUpdateSchema, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReferralCodeApi - axios parameter creator
 */
export const ReferralCodeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Item
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemApiSsoV1ReferralsPost: async (requestBody: { [key: string]: any; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('createItemApiSsoV1ReferralsPost', 'requestBody', requestBody)
            const localVarPath = `/api/sso/v1/referrals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemApiSsoV1ReferralsUidDelete: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteItemApiSsoV1ReferralsUidDelete', 'uid', uid)
            const localVarPath = `/api/sso/v1/referrals/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemsApiSsoV1ReferralsGet: async (offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/v1/referrals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (createdAtFrom !== undefined) {
                localVarQueryParameter['created_at_from'] = (createdAtFrom as any instanceof Date) ?
                    (createdAtFrom as any).toISOString() :
                    createdAtFrom;
            }

            if (createdAtTo !== undefined) {
                localVarQueryParameter['created_at_to'] = (createdAtTo as any instanceof Date) ?
                    (createdAtTo as any).toISOString() :
                    createdAtTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveItemApiSsoV1ReferralsUidGet: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('retrieveItemApiSsoV1ReferralsUidGet', 'uid', uid)
            const localVarPath = `/api/sso/v1/referrals/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Item
         * @param {string} uid 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemApiSsoV1ReferralsUidPatch: async (uid: string, requestBody: { [key: string]: any; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateItemApiSsoV1ReferralsUidPatch', 'uid', uid)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('updateItemApiSsoV1ReferralsUidPatch', 'requestBody', requestBody)
            const localVarPath = `/api/sso/v1/referrals/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReferralCodeApi - functional programming interface
 */
export const ReferralCodeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReferralCodeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Item
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemApiSsoV1ReferralsPost(requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferralCodeSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemApiSsoV1ReferralsPost(requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReferralCodeApi.createItemApiSsoV1ReferralsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemApiSsoV1ReferralsUidDelete(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferralCodeSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemApiSsoV1ReferralsUidDelete(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReferralCodeApi.deleteItemApiSsoV1ReferralsUidDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listItemsApiSsoV1ReferralsGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseReferralCodeSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listItemsApiSsoV1ReferralsGet(offset, limit, createdAtFrom, createdAtTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReferralCodeApi.listItemsApiSsoV1ReferralsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveItemApiSsoV1ReferralsUidGet(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferralCodeSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveItemApiSsoV1ReferralsUidGet(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReferralCodeApi.retrieveItemApiSsoV1ReferralsUidGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Item
         * @param {string} uid 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItemApiSsoV1ReferralsUidPatch(uid: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferralCodeSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateItemApiSsoV1ReferralsUidPatch(uid, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReferralCodeApi.updateItemApiSsoV1ReferralsUidPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReferralCodeApi - factory interface
 */
export const ReferralCodeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReferralCodeApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Item
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemApiSsoV1ReferralsPost(requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): AxiosPromise<ReferralCodeSchema> {
            return localVarFp.createItemApiSsoV1ReferralsPost(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemApiSsoV1ReferralsUidDelete(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<ReferralCodeSchema> {
            return localVarFp.deleteItemApiSsoV1ReferralsUidDelete(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemsApiSsoV1ReferralsGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseReferralCodeSchema> {
            return localVarFp.listItemsApiSsoV1ReferralsGet(offset, limit, createdAtFrom, createdAtTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveItemApiSsoV1ReferralsUidGet(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<ReferralCodeSchema> {
            return localVarFp.retrieveItemApiSsoV1ReferralsUidGet(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Item
         * @param {string} uid 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemApiSsoV1ReferralsUidPatch(uid: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): AxiosPromise<ReferralCodeSchema> {
            return localVarFp.updateItemApiSsoV1ReferralsUidPatch(uid, requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReferralCodeApi - object-oriented interface
 */
export class ReferralCodeApi extends BaseAPI {
    /**
     * 
     * @summary Create Item
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createItemApiSsoV1ReferralsPost(requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig) {
        return ReferralCodeApiFp(this.configuration).createItemApiSsoV1ReferralsPost(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Item
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteItemApiSsoV1ReferralsUidDelete(uid: string, options?: RawAxiosRequestConfig) {
        return ReferralCodeApiFp(this.configuration).deleteItemApiSsoV1ReferralsUidDelete(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Items
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string | null} [createdAtFrom] 
     * @param {string | null} [createdAtTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listItemsApiSsoV1ReferralsGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options?: RawAxiosRequestConfig) {
        return ReferralCodeApiFp(this.configuration).listItemsApiSsoV1ReferralsGet(offset, limit, createdAtFrom, createdAtTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Item
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveItemApiSsoV1ReferralsUidGet(uid: string, options?: RawAxiosRequestConfig) {
        return ReferralCodeApiFp(this.configuration).retrieveItemApiSsoV1ReferralsUidGet(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Item
     * @param {string} uid 
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateItemApiSsoV1ReferralsUidPatch(uid: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig) {
        return ReferralCodeApiFp(this.configuration).updateItemApiSsoV1ReferralsUidPatch(uid, requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RoleApi - axios parameter creator
 */
export const RoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Item
         * @param {RoleCreateSchema} roleCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemApiSsoV1RolesPost: async (roleCreateSchema: RoleCreateSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleCreateSchema' is not null or undefined
            assertParamExists('createItemApiSsoV1RolesPost', 'roleCreateSchema', roleCreateSchema)
            const localVarPath = `/api/sso/v1/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemApiSsoV1RolesUidDelete: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteItemApiSsoV1RolesUidDelete', 'uid', uid)
            const localVarPath = `/api/sso/v1/roles/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemsApiSsoV1RolesGet: async (offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/v1/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (createdAtFrom !== undefined) {
                localVarQueryParameter['created_at_from'] = (createdAtFrom as any instanceof Date) ?
                    (createdAtFrom as any).toISOString() :
                    createdAtFrom;
            }

            if (createdAtTo !== undefined) {
                localVarQueryParameter['created_at_to'] = (createdAtTo as any instanceof Date) ?
                    (createdAtTo as any).toISOString() :
                    createdAtTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveItemApiSsoV1RolesUidGet: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('retrieveItemApiSsoV1RolesUidGet', 'uid', uid)
            const localVarPath = `/api/sso/v1/roles/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Item
         * @param {string} uid 
         * @param {RoleUpdateSchema} roleUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemApiSsoV1RolesUidPatch: async (uid: string, roleUpdateSchema: RoleUpdateSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateItemApiSsoV1RolesUidPatch', 'uid', uid)
            // verify required parameter 'roleUpdateSchema' is not null or undefined
            assertParamExists('updateItemApiSsoV1RolesUidPatch', 'roleUpdateSchema', roleUpdateSchema)
            const localVarPath = `/api/sso/v1/roles/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoleApi - functional programming interface
 */
export const RoleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Item
         * @param {RoleCreateSchema} roleCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemApiSsoV1RolesPost(roleCreateSchema: RoleCreateSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemApiSsoV1RolesPost(roleCreateSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoleApi.createItemApiSsoV1RolesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemApiSsoV1RolesUidDelete(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemApiSsoV1RolesUidDelete(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoleApi.deleteItemApiSsoV1RolesUidDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listItemsApiSsoV1RolesGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseRoleSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listItemsApiSsoV1RolesGet(offset, limit, createdAtFrom, createdAtTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoleApi.listItemsApiSsoV1RolesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveItemApiSsoV1RolesUidGet(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveItemApiSsoV1RolesUidGet(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoleApi.retrieveItemApiSsoV1RolesUidGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Item
         * @param {string} uid 
         * @param {RoleUpdateSchema} roleUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItemApiSsoV1RolesUidPatch(uid: string, roleUpdateSchema: RoleUpdateSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateItemApiSsoV1RolesUidPatch(uid, roleUpdateSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoleApi.updateItemApiSsoV1RolesUidPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RoleApi - factory interface
 */
export const RoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoleApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Item
         * @param {RoleCreateSchema} roleCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemApiSsoV1RolesPost(roleCreateSchema: RoleCreateSchema, options?: RawAxiosRequestConfig): AxiosPromise<RoleSchema> {
            return localVarFp.createItemApiSsoV1RolesPost(roleCreateSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemApiSsoV1RolesUidDelete(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<RoleSchema> {
            return localVarFp.deleteItemApiSsoV1RolesUidDelete(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemsApiSsoV1RolesGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseRoleSchema> {
            return localVarFp.listItemsApiSsoV1RolesGet(offset, limit, createdAtFrom, createdAtTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveItemApiSsoV1RolesUidGet(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<RoleSchema> {
            return localVarFp.retrieveItemApiSsoV1RolesUidGet(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Item
         * @param {string} uid 
         * @param {RoleUpdateSchema} roleUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemApiSsoV1RolesUidPatch(uid: string, roleUpdateSchema: RoleUpdateSchema, options?: RawAxiosRequestConfig): AxiosPromise<RoleSchema> {
            return localVarFp.updateItemApiSsoV1RolesUidPatch(uid, roleUpdateSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoleApi - object-oriented interface
 */
export class RoleApi extends BaseAPI {
    /**
     * 
     * @summary Create Item
     * @param {RoleCreateSchema} roleCreateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createItemApiSsoV1RolesPost(roleCreateSchema: RoleCreateSchema, options?: RawAxiosRequestConfig) {
        return RoleApiFp(this.configuration).createItemApiSsoV1RolesPost(roleCreateSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Item
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteItemApiSsoV1RolesUidDelete(uid: string, options?: RawAxiosRequestConfig) {
        return RoleApiFp(this.configuration).deleteItemApiSsoV1RolesUidDelete(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Items
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string | null} [createdAtFrom] 
     * @param {string | null} [createdAtTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listItemsApiSsoV1RolesGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options?: RawAxiosRequestConfig) {
        return RoleApiFp(this.configuration).listItemsApiSsoV1RolesGet(offset, limit, createdAtFrom, createdAtTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Item
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveItemApiSsoV1RolesUidGet(uid: string, options?: RawAxiosRequestConfig) {
        return RoleApiFp(this.configuration).retrieveItemApiSsoV1RolesUidGet(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Item
     * @param {string} uid 
     * @param {RoleUpdateSchema} roleUpdateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateItemApiSsoV1RolesUidPatch(uid: string, roleUpdateSchema: RoleUpdateSchema, options?: RawAxiosRequestConfig) {
        return RoleApiFp(this.configuration).updateItemApiSsoV1RolesUidPatch(uid, roleUpdateSchema, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TenantApi - axios parameter creator
 */
export const TenantApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Item
         * @param {TenantCreateSchema} tenantCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemApiSsoV1TenantsPost: async (tenantCreateSchema: TenantCreateSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantCreateSchema' is not null or undefined
            assertParamExists('createItemApiSsoV1TenantsPost', 'tenantCreateSchema', tenantCreateSchema)
            const localVarPath = `/api/sso/v1/tenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tenantCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemApiSsoV1TenantsUidDelete: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteItemApiSsoV1TenantsUidDelete', 'uid', uid)
            const localVarPath = `/api/sso/v1/tenants/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemsApiSsoV1TenantsGet: async (offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/v1/tenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (createdAtFrom !== undefined) {
                localVarQueryParameter['created_at_from'] = (createdAtFrom as any instanceof Date) ?
                    (createdAtFrom as any).toISOString() :
                    createdAtFrom;
            }

            if (createdAtTo !== undefined) {
                localVarQueryParameter['created_at_to'] = (createdAtTo as any instanceof Date) ?
                    (createdAtTo as any).toISOString() :
                    createdAtTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveItemApiSsoV1TenantsUidGet: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('retrieveItemApiSsoV1TenantsUidGet', 'uid', uid)
            const localVarPath = `/api/sso/v1/tenants/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Item
         * @param {string} uid 
         * @param {TenantUpdateSchema} tenantUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemApiSsoV1TenantsUidPatch: async (uid: string, tenantUpdateSchema: TenantUpdateSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateItemApiSsoV1TenantsUidPatch', 'uid', uid)
            // verify required parameter 'tenantUpdateSchema' is not null or undefined
            assertParamExists('updateItemApiSsoV1TenantsUidPatch', 'tenantUpdateSchema', tenantUpdateSchema)
            const localVarPath = `/api/sso/v1/tenants/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tenantUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TenantApi - functional programming interface
 */
export const TenantApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TenantApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Item
         * @param {TenantCreateSchema} tenantCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemApiSsoV1TenantsPost(tenantCreateSchema: TenantCreateSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantRetrieveSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemApiSsoV1TenantsPost(tenantCreateSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantApi.createItemApiSsoV1TenantsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemApiSsoV1TenantsUidDelete(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantRetrieveSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemApiSsoV1TenantsUidDelete(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantApi.deleteItemApiSsoV1TenantsUidDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listItemsApiSsoV1TenantsGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseTenantRetrieveSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listItemsApiSsoV1TenantsGet(offset, limit, createdAtFrom, createdAtTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantApi.listItemsApiSsoV1TenantsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveItemApiSsoV1TenantsUidGet(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantRetrieveSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveItemApiSsoV1TenantsUidGet(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantApi.retrieveItemApiSsoV1TenantsUidGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Item
         * @param {string} uid 
         * @param {TenantUpdateSchema} tenantUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItemApiSsoV1TenantsUidPatch(uid: string, tenantUpdateSchema: TenantUpdateSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantRetrieveSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateItemApiSsoV1TenantsUidPatch(uid, tenantUpdateSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantApi.updateItemApiSsoV1TenantsUidPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TenantApi - factory interface
 */
export const TenantApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TenantApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Item
         * @param {TenantCreateSchema} tenantCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemApiSsoV1TenantsPost(tenantCreateSchema: TenantCreateSchema, options?: RawAxiosRequestConfig): AxiosPromise<TenantRetrieveSchema> {
            return localVarFp.createItemApiSsoV1TenantsPost(tenantCreateSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemApiSsoV1TenantsUidDelete(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<TenantRetrieveSchema> {
            return localVarFp.deleteItemApiSsoV1TenantsUidDelete(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemsApiSsoV1TenantsGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseTenantRetrieveSchema> {
            return localVarFp.listItemsApiSsoV1TenantsGet(offset, limit, createdAtFrom, createdAtTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveItemApiSsoV1TenantsUidGet(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<TenantRetrieveSchema> {
            return localVarFp.retrieveItemApiSsoV1TenantsUidGet(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Item
         * @param {string} uid 
         * @param {TenantUpdateSchema} tenantUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemApiSsoV1TenantsUidPatch(uid: string, tenantUpdateSchema: TenantUpdateSchema, options?: RawAxiosRequestConfig): AxiosPromise<TenantRetrieveSchema> {
            return localVarFp.updateItemApiSsoV1TenantsUidPatch(uid, tenantUpdateSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TenantApi - object-oriented interface
 */
export class TenantApi extends BaseAPI {
    /**
     * 
     * @summary Create Item
     * @param {TenantCreateSchema} tenantCreateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createItemApiSsoV1TenantsPost(tenantCreateSchema: TenantCreateSchema, options?: RawAxiosRequestConfig) {
        return TenantApiFp(this.configuration).createItemApiSsoV1TenantsPost(tenantCreateSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Item
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteItemApiSsoV1TenantsUidDelete(uid: string, options?: RawAxiosRequestConfig) {
        return TenantApiFp(this.configuration).deleteItemApiSsoV1TenantsUidDelete(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Items
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string | null} [createdAtFrom] 
     * @param {string | null} [createdAtTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listItemsApiSsoV1TenantsGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options?: RawAxiosRequestConfig) {
        return TenantApiFp(this.configuration).listItemsApiSsoV1TenantsGet(offset, limit, createdAtFrom, createdAtTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Item
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveItemApiSsoV1TenantsUidGet(uid: string, options?: RawAxiosRequestConfig) {
        return TenantApiFp(this.configuration).retrieveItemApiSsoV1TenantsUidGet(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Item
     * @param {string} uid 
     * @param {TenantUpdateSchema} tenantUpdateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateItemApiSsoV1TenantsUidPatch(uid: string, tenantUpdateSchema: TenantUpdateSchema, options?: RawAxiosRequestConfig) {
        return TenantApiFp(this.configuration).updateItemApiSsoV1TenantsUidPatch(uid, tenantUpdateSchema, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a new credential to a user.
         * @summary Create Credential
         * @param {string} uid 
         * @param {CredentialCreateSchema} credentialCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredentialApiSsoV1UsersUidCredentialsPost: async (uid: string, credentialCreateSchema: CredentialCreateSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('createCredentialApiSsoV1UsersUidCredentialsPost', 'uid', uid)
            // verify required parameter 'credentialCreateSchema' is not null or undefined
            assertParamExists('createCredentialApiSsoV1UsersUidCredentialsPost', 'credentialCreateSchema', credentialCreateSchema)
            const localVarPath = `/api/sso/v1/users/{uid}/credentials`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(credentialCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new identifier to a user.
         * @summary Create Identifier
         * @param {string} uid 
         * @param {UserIdentifierCreateSchema} userIdentifierCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIdentifierApiSsoV1UsersUidIdentifiersPost: async (uid: string, userIdentifierCreateSchema: UserIdentifierCreateSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('createIdentifierApiSsoV1UsersUidIdentifiersPost', 'uid', uid)
            // verify required parameter 'userIdentifierCreateSchema' is not null or undefined
            assertParamExists('createIdentifierApiSsoV1UsersUidIdentifiersPost', 'userIdentifierCreateSchema', userIdentifierCreateSchema)
            const localVarPath = `/api/sso/v1/users/{uid}/identifiers`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userIdentifierCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Item
         * @param {UserCreateSchema} userCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemApiSsoV1UsersPost: async (userCreateSchema: UserCreateSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreateSchema' is not null or undefined
            assertParamExists('createItemApiSsoV1UsersPost', 'userCreateSchema', userCreateSchema)
            const localVarPath = `/api/sso/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a credential.
         * @summary Delete Credential
         * @param {string} uid 
         * @param {string} credentialId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredentialApiSsoV1UsersUidCredentialsCredentialIdDelete: async (uid: string, credentialId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteCredentialApiSsoV1UsersUidCredentialsCredentialIdDelete', 'uid', uid)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('deleteCredentialApiSsoV1UsersUidCredentialsCredentialIdDelete', 'credentialId', credentialId)
            const localVarPath = `/api/sso/v1/users/{uid}/credentials/{credential_id}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"credential_id"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an identifier.
         * @summary Delete Identifier
         * @param {string} uid 
         * @param {string} identifierId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentifierApiSsoV1UsersUidIdentifiersIdentifierIdDelete: async (uid: string, identifierId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteIdentifierApiSsoV1UsersUidIdentifiersIdentifierIdDelete', 'uid', uid)
            // verify required parameter 'identifierId' is not null or undefined
            assertParamExists('deleteIdentifierApiSsoV1UsersUidIdentifiersIdentifierIdDelete', 'identifierId', identifierId)
            const localVarPath = `/api/sso/v1/users/{uid}/identifiers/{identifier_id}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"identifier_id"}}`, encodeURIComponent(String(identifierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemApiSsoV1UsersUidDelete: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteItemApiSsoV1UsersUidDelete', 'uid', uid)
            const localVarPath = `/api/sso/v1/users/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Impersonate Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impersonateItemApiSsoV1UsersUidImpersonatePost: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('impersonateItemApiSsoV1UsersUidImpersonatePost', 'uid', uid)
            const localVarPath = `/api/sso/v1/users/{uid}/impersonate`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all credentials for a user (without sensitive data).
         * @summary List Credentials
         * @param {string} uid 
         * @param {number} [offset] Number of items to skip
         * @param {number} [limit] Number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentialsApiSsoV1UsersUidCredentialsGet: async (uid: string, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('listCredentialsApiSsoV1UsersUidCredentialsGet', 'uid', uid)
            const localVarPath = `/api/sso/v1/users/{uid}/credentials`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all identifiers for a user.
         * @summary List Identifiers
         * @param {string} uid 
         * @param {number} [offset] Number of items to skip
         * @param {number} [limit] Number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIdentifiersApiSsoV1UsersUidIdentifiersGet: async (uid: string, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('listIdentifiersApiSsoV1UsersUidIdentifiersGet', 'uid', uid)
            const localVarPath = `/api/sso/v1/users/{uid}/identifiers`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {AuthIdentifier | null} [identifierType] 
         * @param {string | null} [identifier] 
         * @param {string | null} [role] 
         * @param {boolean | null} [isActive] 
         * @param {boolean | null} [isLimited] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemsApiSsoV1UsersGet: async (offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, identifierType?: AuthIdentifier | null, identifier?: string | null, role?: string | null, isActive?: boolean | null, isLimited?: boolean | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (createdAtFrom !== undefined) {
                localVarQueryParameter['created_at_from'] = (createdAtFrom as any instanceof Date) ?
                    (createdAtFrom as any).toISOString() :
                    createdAtFrom;
            }

            if (createdAtTo !== undefined) {
                localVarQueryParameter['created_at_to'] = (createdAtTo as any instanceof Date) ?
                    (createdAtTo as any).toISOString() :
                    createdAtTo;
            }

            if (identifierType !== undefined) {
                localVarQueryParameter['identifier_type'] = identifierType;
            }

            if (identifier !== undefined) {
                localVarQueryParameter['identifier'] = identifier;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (isLimited !== undefined) {
                localVarQueryParameter['is_limited'] = isLimited;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resend verification code for an identifier.
         * @summary Resend Verification
         * @param {string} uid 
         * @param {string} identifierId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendVerificationApiSsoV1UsersUidIdentifiersIdentifierIdResendPost: async (uid: string, identifierId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('resendVerificationApiSsoV1UsersUidIdentifiersIdentifierIdResendPost', 'uid', uid)
            // verify required parameter 'identifierId' is not null or undefined
            assertParamExists('resendVerificationApiSsoV1UsersUidIdentifiersIdentifierIdResendPost', 'identifierId', identifierId)
            const localVarPath = `/api/sso/v1/users/{uid}/identifiers/{identifier_id}/resend`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"identifier_id"}}`, encodeURIComponent(String(identifierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset a specific credential (e.g., generate new TOTP secret).
         * @summary Reset Credential
         * @param {string} uid 
         * @param {string} credentialId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetCredentialApiSsoV1UsersUidCredentialsCredentialIdResetPost: async (uid: string, credentialId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('resetCredentialApiSsoV1UsersUidCredentialsCredentialIdResetPost', 'uid', uid)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('resetCredentialApiSsoV1UsersUidCredentialsCredentialIdResetPost', 'credentialId', credentialId)
            const localVarPath = `/api/sso/v1/users/{uid}/credentials/{credential_id}/reset`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"credential_id"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveItemApiSsoV1UsersUidGet: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('retrieveItemApiSsoV1UsersUidGet', 'uid', uid)
            const localVarPath = `/api/sso/v1/users/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing identifier.
         * @summary Update Identifier
         * @param {string} uid 
         * @param {string} identifierId 
         * @param {UserIdentifierUpdateSchema} userIdentifierUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIdentifierApiSsoV1UsersUidIdentifiersIdentifierIdPatch: async (uid: string, identifierId: string, userIdentifierUpdateSchema: UserIdentifierUpdateSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateIdentifierApiSsoV1UsersUidIdentifiersIdentifierIdPatch', 'uid', uid)
            // verify required parameter 'identifierId' is not null or undefined
            assertParamExists('updateIdentifierApiSsoV1UsersUidIdentifiersIdentifierIdPatch', 'identifierId', identifierId)
            // verify required parameter 'userIdentifierUpdateSchema' is not null or undefined
            assertParamExists('updateIdentifierApiSsoV1UsersUidIdentifiersIdentifierIdPatch', 'userIdentifierUpdateSchema', userIdentifierUpdateSchema)
            const localVarPath = `/api/sso/v1/users/{uid}/identifiers/{identifier_id}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"identifier_id"}}`, encodeURIComponent(String(identifierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userIdentifierUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Item
         * @param {string} uid 
         * @param {UserUpdateSchema} userUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemApiSsoV1UsersUidPatch: async (uid: string, userUpdateSchema: UserUpdateSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateItemApiSsoV1UsersUidPatch', 'uid', uid)
            // verify required parameter 'userUpdateSchema' is not null or undefined
            assertParamExists('updateItemApiSsoV1UsersUidPatch', 'userUpdateSchema', userUpdateSchema)
            const localVarPath = `/api/sso/v1/users/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a new credential to a user.
         * @summary Create Credential
         * @param {string} uid 
         * @param {CredentialCreateSchema} credentialCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCredentialApiSsoV1UsersUidCredentialsPost(uid: string, credentialCreateSchema: CredentialCreateSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCredentialApiSsoV1UsersUidCredentialsPost(uid, credentialCreateSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.createCredentialApiSsoV1UsersUidCredentialsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a new identifier to a user.
         * @summary Create Identifier
         * @param {string} uid 
         * @param {UserIdentifierCreateSchema} userIdentifierCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIdentifierApiSsoV1UsersUidIdentifiersPost(uid: string, userIdentifierCreateSchema: UserIdentifierCreateSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserIdentifierSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createIdentifierApiSsoV1UsersUidIdentifiersPost(uid, userIdentifierCreateSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.createIdentifierApiSsoV1UsersUidIdentifiersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Item
         * @param {UserCreateSchema} userCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemApiSsoV1UsersPost(userCreateSchema: UserCreateSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemApiSsoV1UsersPost(userCreateSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.createItemApiSsoV1UsersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a credential.
         * @summary Delete Credential
         * @param {string} uid 
         * @param {string} credentialId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCredentialApiSsoV1UsersUidCredentialsCredentialIdDelete(uid: string, credentialId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCredentialApiSsoV1UsersUidCredentialsCredentialIdDelete(uid, credentialId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.deleteCredentialApiSsoV1UsersUidCredentialsCredentialIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an identifier.
         * @summary Delete Identifier
         * @param {string} uid 
         * @param {string} identifierId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIdentifierApiSsoV1UsersUidIdentifiersIdentifierIdDelete(uid: string, identifierId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserIdentifier>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIdentifierApiSsoV1UsersUidIdentifiersIdentifierIdDelete(uid, identifierId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.deleteIdentifierApiSsoV1UsersUidIdentifiersIdentifierIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemApiSsoV1UsersUidDelete(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemApiSsoV1UsersUidDelete(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.deleteItemApiSsoV1UsersUidDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Impersonate Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async impersonateItemApiSsoV1UsersUidImpersonatePost(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseEntitySchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.impersonateItemApiSsoV1UsersUidImpersonatePost(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.impersonateItemApiSsoV1UsersUidImpersonatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all credentials for a user (without sensitive data).
         * @summary List Credentials
         * @param {string} uid 
         * @param {number} [offset] Number of items to skip
         * @param {number} [limit] Number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCredentialsApiSsoV1UsersUidCredentialsGet(uid: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseCredentialResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCredentialsApiSsoV1UsersUidCredentialsGet(uid, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.listCredentialsApiSsoV1UsersUidCredentialsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all identifiers for a user.
         * @summary List Identifiers
         * @param {string} uid 
         * @param {number} [offset] Number of items to skip
         * @param {number} [limit] Number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listIdentifiersApiSsoV1UsersUidIdentifiersGet(uid: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseUserIdentifierSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdentifiersApiSsoV1UsersUidIdentifiersGet(uid, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.listIdentifiersApiSsoV1UsersUidIdentifiersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {AuthIdentifier | null} [identifierType] 
         * @param {string | null} [identifier] 
         * @param {string | null} [role] 
         * @param {boolean | null} [isActive] 
         * @param {boolean | null} [isLimited] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listItemsApiSsoV1UsersGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, identifierType?: AuthIdentifier | null, identifier?: string | null, role?: string | null, isActive?: boolean | null, isLimited?: boolean | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listItemsApiSsoV1UsersGet(offset, limit, createdAtFrom, createdAtTo, identifierType, identifier, role, isActive, isLimited, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.listItemsApiSsoV1UsersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resend verification code for an identifier.
         * @summary Resend Verification
         * @param {string} uid 
         * @param {string} identifierId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendVerificationApiSsoV1UsersUidIdentifiersIdentifierIdResendPost(uid: string, identifierId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendVerificationApiSsoV1UsersUidIdentifiersIdentifierIdResendPost(uid, identifierId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.resendVerificationApiSsoV1UsersUidIdentifiersIdentifierIdResendPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reset a specific credential (e.g., generate new TOTP secret).
         * @summary Reset Credential
         * @param {string} uid 
         * @param {string} credentialId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetCredentialApiSsoV1UsersUidCredentialsCredentialIdResetPost(uid: string, credentialId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetCredentialApiSsoV1UsersUidCredentialsCredentialIdResetPost(uid, credentialId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.resetCredentialApiSsoV1UsersUidCredentialsCredentialIdResetPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveItemApiSsoV1UsersUidGet(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveItemApiSsoV1UsersUidGet(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.retrieveItemApiSsoV1UsersUidGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing identifier.
         * @summary Update Identifier
         * @param {string} uid 
         * @param {string} identifierId 
         * @param {UserIdentifierUpdateSchema} userIdentifierUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateIdentifierApiSsoV1UsersUidIdentifiersIdentifierIdPatch(uid: string, identifierId: string, userIdentifierUpdateSchema: UserIdentifierUpdateSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserIdentifierSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateIdentifierApiSsoV1UsersUidIdentifiersIdentifierIdPatch(uid, identifierId, userIdentifierUpdateSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.updateIdentifierApiSsoV1UsersUidIdentifiersIdentifierIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Item
         * @param {string} uid 
         * @param {UserUpdateSchema} userUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItemApiSsoV1UsersUidPatch(uid: string, userUpdateSchema: UserUpdateSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateItemApiSsoV1UsersUidPatch(uid, userUpdateSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.updateItemApiSsoV1UsersUidPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Add a new credential to a user.
         * @summary Create Credential
         * @param {string} uid 
         * @param {CredentialCreateSchema} credentialCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredentialApiSsoV1UsersUidCredentialsPost(uid: string, credentialCreateSchema: CredentialCreateSchema, options?: RawAxiosRequestConfig): AxiosPromise<CredentialResponseSchema> {
            return localVarFp.createCredentialApiSsoV1UsersUidCredentialsPost(uid, credentialCreateSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new identifier to a user.
         * @summary Create Identifier
         * @param {string} uid 
         * @param {UserIdentifierCreateSchema} userIdentifierCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIdentifierApiSsoV1UsersUidIdentifiersPost(uid: string, userIdentifierCreateSchema: UserIdentifierCreateSchema, options?: RawAxiosRequestConfig): AxiosPromise<UserIdentifierSchema> {
            return localVarFp.createIdentifierApiSsoV1UsersUidIdentifiersPost(uid, userIdentifierCreateSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Item
         * @param {UserCreateSchema} userCreateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemApiSsoV1UsersPost(userCreateSchema: UserCreateSchema, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.createItemApiSsoV1UsersPost(userCreateSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a credential.
         * @summary Delete Credential
         * @param {string} uid 
         * @param {string} credentialId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredentialApiSsoV1UsersUidCredentialsCredentialIdDelete(uid: string, credentialId: string, options?: RawAxiosRequestConfig): AxiosPromise<Credential> {
            return localVarFp.deleteCredentialApiSsoV1UsersUidCredentialsCredentialIdDelete(uid, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an identifier.
         * @summary Delete Identifier
         * @param {string} uid 
         * @param {string} identifierId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentifierApiSsoV1UsersUidIdentifiersIdentifierIdDelete(uid: string, identifierId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserIdentifier> {
            return localVarFp.deleteIdentifierApiSsoV1UsersUidIdentifiersIdentifierIdDelete(uid, identifierId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemApiSsoV1UsersUidDelete(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.deleteItemApiSsoV1UsersUidDelete(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Impersonate Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impersonateItemApiSsoV1UsersUidImpersonatePost(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseEntitySchema> {
            return localVarFp.impersonateItemApiSsoV1UsersUidImpersonatePost(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * List all credentials for a user (without sensitive data).
         * @summary List Credentials
         * @param {string} uid 
         * @param {number} [offset] Number of items to skip
         * @param {number} [limit] Number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentialsApiSsoV1UsersUidCredentialsGet(uid: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseCredentialResponseSchema> {
            return localVarFp.listCredentialsApiSsoV1UsersUidCredentialsGet(uid, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * List all identifiers for a user.
         * @summary List Identifiers
         * @param {string} uid 
         * @param {number} [offset] Number of items to skip
         * @param {number} [limit] Number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIdentifiersApiSsoV1UsersUidIdentifiersGet(uid: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseUserIdentifierSchema> {
            return localVarFp.listIdentifiersApiSsoV1UsersUidIdentifiersGet(uid, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {AuthIdentifier | null} [identifierType] 
         * @param {string | null} [identifier] 
         * @param {string | null} [role] 
         * @param {boolean | null} [isActive] 
         * @param {boolean | null} [isLimited] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemsApiSsoV1UsersGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, identifierType?: AuthIdentifier | null, identifier?: string | null, role?: string | null, isActive?: boolean | null, isLimited?: boolean | null, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseUserResponse> {
            return localVarFp.listItemsApiSsoV1UsersGet(offset, limit, createdAtFrom, createdAtTo, identifierType, identifier, role, isActive, isLimited, options).then((request) => request(axios, basePath));
        },
        /**
         * Resend verification code for an identifier.
         * @summary Resend Verification
         * @param {string} uid 
         * @param {string} identifierId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendVerificationApiSsoV1UsersUidIdentifiersIdentifierIdResendPost(uid: string, identifierId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.resendVerificationApiSsoV1UsersUidIdentifiersIdentifierIdResendPost(uid, identifierId, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset a specific credential (e.g., generate new TOTP secret).
         * @summary Reset Credential
         * @param {string} uid 
         * @param {string} credentialId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetCredentialApiSsoV1UsersUidCredentialsCredentialIdResetPost(uid: string, credentialId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.resetCredentialApiSsoV1UsersUidCredentialsCredentialIdResetPost(uid, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveItemApiSsoV1UsersUidGet(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.retrieveItemApiSsoV1UsersUidGet(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing identifier.
         * @summary Update Identifier
         * @param {string} uid 
         * @param {string} identifierId 
         * @param {UserIdentifierUpdateSchema} userIdentifierUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIdentifierApiSsoV1UsersUidIdentifiersIdentifierIdPatch(uid: string, identifierId: string, userIdentifierUpdateSchema: UserIdentifierUpdateSchema, options?: RawAxiosRequestConfig): AxiosPromise<UserIdentifierSchema> {
            return localVarFp.updateIdentifierApiSsoV1UsersUidIdentifiersIdentifierIdPatch(uid, identifierId, userIdentifierUpdateSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Item
         * @param {string} uid 
         * @param {UserUpdateSchema} userUpdateSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemApiSsoV1UsersUidPatch(uid: string, userUpdateSchema: UserUpdateSchema, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.updateItemApiSsoV1UsersUidPatch(uid, userUpdateSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 */
export class UserApi extends BaseAPI {
    /**
     * Add a new credential to a user.
     * @summary Create Credential
     * @param {string} uid 
     * @param {CredentialCreateSchema} credentialCreateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createCredentialApiSsoV1UsersUidCredentialsPost(uid: string, credentialCreateSchema: CredentialCreateSchema, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).createCredentialApiSsoV1UsersUidCredentialsPost(uid, credentialCreateSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new identifier to a user.
     * @summary Create Identifier
     * @param {string} uid 
     * @param {UserIdentifierCreateSchema} userIdentifierCreateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createIdentifierApiSsoV1UsersUidIdentifiersPost(uid: string, userIdentifierCreateSchema: UserIdentifierCreateSchema, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).createIdentifierApiSsoV1UsersUidIdentifiersPost(uid, userIdentifierCreateSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Item
     * @param {UserCreateSchema} userCreateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createItemApiSsoV1UsersPost(userCreateSchema: UserCreateSchema, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).createItemApiSsoV1UsersPost(userCreateSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a credential.
     * @summary Delete Credential
     * @param {string} uid 
     * @param {string} credentialId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteCredentialApiSsoV1UsersUidCredentialsCredentialIdDelete(uid: string, credentialId: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteCredentialApiSsoV1UsersUidCredentialsCredentialIdDelete(uid, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an identifier.
     * @summary Delete Identifier
     * @param {string} uid 
     * @param {string} identifierId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteIdentifierApiSsoV1UsersUidIdentifiersIdentifierIdDelete(uid: string, identifierId: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteIdentifierApiSsoV1UsersUidIdentifiersIdentifierIdDelete(uid, identifierId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Item
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteItemApiSsoV1UsersUidDelete(uid: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteItemApiSsoV1UsersUidDelete(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Impersonate Item
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public impersonateItemApiSsoV1UsersUidImpersonatePost(uid: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).impersonateItemApiSsoV1UsersUidImpersonatePost(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all credentials for a user (without sensitive data).
     * @summary List Credentials
     * @param {string} uid 
     * @param {number} [offset] Number of items to skip
     * @param {number} [limit] Number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listCredentialsApiSsoV1UsersUidCredentialsGet(uid: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).listCredentialsApiSsoV1UsersUidCredentialsGet(uid, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all identifiers for a user.
     * @summary List Identifiers
     * @param {string} uid 
     * @param {number} [offset] Number of items to skip
     * @param {number} [limit] Number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listIdentifiersApiSsoV1UsersUidIdentifiersGet(uid: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).listIdentifiersApiSsoV1UsersUidIdentifiersGet(uid, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Items
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string | null} [createdAtFrom] 
     * @param {string | null} [createdAtTo] 
     * @param {AuthIdentifier | null} [identifierType] 
     * @param {string | null} [identifier] 
     * @param {string | null} [role] 
     * @param {boolean | null} [isActive] 
     * @param {boolean | null} [isLimited] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listItemsApiSsoV1UsersGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, identifierType?: AuthIdentifier | null, identifier?: string | null, role?: string | null, isActive?: boolean | null, isLimited?: boolean | null, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).listItemsApiSsoV1UsersGet(offset, limit, createdAtFrom, createdAtTo, identifierType, identifier, role, isActive, isLimited, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resend verification code for an identifier.
     * @summary Resend Verification
     * @param {string} uid 
     * @param {string} identifierId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resendVerificationApiSsoV1UsersUidIdentifiersIdentifierIdResendPost(uid: string, identifierId: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).resendVerificationApiSsoV1UsersUidIdentifiersIdentifierIdResendPost(uid, identifierId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset a specific credential (e.g., generate new TOTP secret).
     * @summary Reset Credential
     * @param {string} uid 
     * @param {string} credentialId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resetCredentialApiSsoV1UsersUidCredentialsCredentialIdResetPost(uid: string, credentialId: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).resetCredentialApiSsoV1UsersUidCredentialsCredentialIdResetPost(uid, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Item
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveItemApiSsoV1UsersUidGet(uid: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).retrieveItemApiSsoV1UsersUidGet(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing identifier.
     * @summary Update Identifier
     * @param {string} uid 
     * @param {string} identifierId 
     * @param {UserIdentifierUpdateSchema} userIdentifierUpdateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateIdentifierApiSsoV1UsersUidIdentifiersIdentifierIdPatch(uid: string, identifierId: string, userIdentifierUpdateSchema: UserIdentifierUpdateSchema, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).updateIdentifierApiSsoV1UsersUidIdentifiersIdentifierIdPatch(uid, identifierId, userIdentifierUpdateSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Item
     * @param {string} uid 
     * @param {UserUpdateSchema} userUpdateSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateItemApiSsoV1UsersUidPatch(uid: string, userUpdateSchema: UserUpdateSchema, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).updateItemApiSsoV1UsersUidPatch(uid, userUpdateSchema, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkspaceApi - axios parameter creator
 */
export const WorkspaceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Item
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemApiSsoV1WorkspacesPost: async (requestBody: { [key: string]: any; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('createItemApiSsoV1WorkspacesPost', 'requestBody', requestBody)
            const localVarPath = `/api/sso/v1/workspaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemApiSsoV1WorkspacesUidDelete: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteItemApiSsoV1WorkspacesUidDelete', 'uid', uid)
            const localVarPath = `/api/sso/v1/workspaces/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemsApiSsoV1WorkspacesGet: async (offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/v1/workspaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (createdAtFrom !== undefined) {
                localVarQueryParameter['created_at_from'] = (createdAtFrom as any instanceof Date) ?
                    (createdAtFrom as any).toISOString() :
                    createdAtFrom;
            }

            if (createdAtTo !== undefined) {
                localVarQueryParameter['created_at_to'] = (createdAtTo as any instanceof Date) ?
                    (createdAtTo as any).toISOString() :
                    createdAtTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveItemApiSsoV1WorkspacesUidGet: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('retrieveItemApiSsoV1WorkspacesUidGet', 'uid', uid)
            const localVarPath = `/api/sso/v1/workspaces/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Item
         * @param {string} uid 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemApiSsoV1WorkspacesUidPatch: async (uid: string, requestBody: { [key: string]: any; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateItemApiSsoV1WorkspacesUidPatch', 'uid', uid)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('updateItemApiSsoV1WorkspacesUidPatch', 'requestBody', requestBody)
            const localVarPath = `/api/sso/v1/workspaces/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkspaceApi - functional programming interface
 */
export const WorkspaceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkspaceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Item
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemApiSsoV1WorkspacesPost(requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemApiSsoV1WorkspacesPost(requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.createItemApiSsoV1WorkspacesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemApiSsoV1WorkspacesUidDelete(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemApiSsoV1WorkspacesUidDelete(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.deleteItemApiSsoV1WorkspacesUidDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listItemsApiSsoV1WorkspacesGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseWorkspaceSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listItemsApiSsoV1WorkspacesGet(offset, limit, createdAtFrom, createdAtTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.listItemsApiSsoV1WorkspacesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveItemApiSsoV1WorkspacesUidGet(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveItemApiSsoV1WorkspacesUidGet(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.retrieveItemApiSsoV1WorkspacesUidGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Item
         * @param {string} uid 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItemApiSsoV1WorkspacesUidPatch(uid: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateItemApiSsoV1WorkspacesUidPatch(uid, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.updateItemApiSsoV1WorkspacesUidPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkspaceApi - factory interface
 */
export const WorkspaceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkspaceApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Item
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemApiSsoV1WorkspacesPost(requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceSchema> {
            return localVarFp.createItemApiSsoV1WorkspacesPost(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemApiSsoV1WorkspacesUidDelete(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceSchema> {
            return localVarFp.deleteItemApiSsoV1WorkspacesUidDelete(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Items
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string | null} [createdAtFrom] 
         * @param {string | null} [createdAtTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemsApiSsoV1WorkspacesGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseWorkspaceSchema> {
            return localVarFp.listItemsApiSsoV1WorkspacesGet(offset, limit, createdAtFrom, createdAtTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Item
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveItemApiSsoV1WorkspacesUidGet(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceSchema> {
            return localVarFp.retrieveItemApiSsoV1WorkspacesUidGet(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Item
         * @param {string} uid 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemApiSsoV1WorkspacesUidPatch(uid: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceSchema> {
            return localVarFp.updateItemApiSsoV1WorkspacesUidPatch(uid, requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkspaceApi - object-oriented interface
 */
export class WorkspaceApi extends BaseAPI {
    /**
     * 
     * @summary Create Item
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createItemApiSsoV1WorkspacesPost(requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).createItemApiSsoV1WorkspacesPost(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Item
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteItemApiSsoV1WorkspacesUidDelete(uid: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).deleteItemApiSsoV1WorkspacesUidDelete(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Items
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string | null} [createdAtFrom] 
     * @param {string | null} [createdAtTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listItemsApiSsoV1WorkspacesGet(offset?: number, limit?: number, createdAtFrom?: string | null, createdAtTo?: string | null, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).listItemsApiSsoV1WorkspacesGet(offset, limit, createdAtFrom, createdAtTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Item
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveItemApiSsoV1WorkspacesUidGet(uid: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).retrieveItemApiSsoV1WorkspacesUidGet(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Item
     * @param {string} uid 
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateItemApiSsoV1WorkspacesUidPatch(uid: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).updateItemApiSsoV1WorkspacesUidPatch(uid, requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



